////////////////////////////////////////////////////////////////////////////////
// Подсистема "Электронная подпись".
// 
////////////////////////////////////////////////////////////////////////////////

#Область СлужебныйПрограммныйИнтерфейс

////////////////////////////////////////////////////////////////////////////////
// Добавление обработчиков служебных событий (подписок).

// См. описание этой же процедуры в модуле СтандартныеПодсистемыСервер.
Процедура ПриДобавленииОбработчиковСлужебныхСобытий(КлиентскиеОбработчики, СерверныеОбработчики) Экспорт
	
	// СЕРВЕРНЫЕ ОБРАБОТЧИКИ.
	
	ИмяМодуля = "ЭлектроннаяПодписьСлужебный";
	
	ИмяСобытия = "СтандартныеПодсистемы.ОбновлениеВерсииИБ\ПриДобавленииОбработчиковОбновления";
	СерверныеОбработчики[ИмяСобытия].Добавить(ИмяМодуля);
	
	ИмяСобытия = "СтандартныеПодсистемы.БазоваяФункциональность\ПриДобавленииПереименованийОбъектовМетаданных";
	СерверныеОбработчики[ИмяСобытия].Добавить(ИмяМодуля);
	
	ИмяСобытия = "СтандартныеПодсистемы.БазоваяФункциональность\ПриДобавленииПараметровРаботыКлиента";
	СерверныеОбработчики[ИмяСобытия].Добавить(ИмяМодуля);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработчики служебных событий.

// Добавляет процедуры-обработчики обновления, необходимые данной подсистеме.
//
// Параметры:
//   Обработчики - ТаблицаЗначений - см. ОбновлениеИнформационнойБазы.НоваяТаблицаОбработчиковОбновления().
//
Процедура ПриДобавленииОбработчиковОбновления(Обработчики) Экспорт
	
	Обработчик = Обработчики.Добавить();
	Обработчик.НачальноеЗаполнение = Истина;
	Обработчик.Процедура = "Справочники.ПрограммыЭлектроннойПодписиИШифрования.ЗаполнитьНачальныеНастройки";
	Обработчик.РежимВыполнения = "Монопольно";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.2.4.7";
	Обработчик.Процедура = "ЭлектроннаяПодписьСлужебный.ПеренестиНастройкиМенеджераКриптографии";
	Обработчик.РежимВыполнения = "Монопольно";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.НачальноеЗаполнение = Истина;
	Обработчик.Версия = "2.3.3.28";
	Обработчик.Процедура = "Справочники.ПрограммыЭлектроннойПодписиИШифрования.ЗаполнитьНачальныеНастройкиВОблачномСервисе";
	Обработчик.РежимВыполнения = "Монопольно";	
	
КонецПроцедуры

// Заполняет переименования тех объектов метаданных, которые невозможно
//   автоматически найти по типу, но ссылки на которые требуется сохранять
//   в базе данных (например: подсистемы, роли).
//
// См. также:
//   ОбщегоНазначения.ДобавитьПереименование().
//
Процедура ПриДобавленииПереименованийОбъектовМетаданных(Итог) Экспорт
	
	Библиотека = "СтандартныеПодсистемы";
	
	СтароеИмя = "Роль.ИспользованиеЭЦП";
	НовоеИмя  = "Роль.ИспользованиеЭП";
	ОбщегоНазначения.ДобавитьПереименование(Итог, "2.2.1.7", СтароеИмя, НовоеИмя, Библиотека);
	
	СтароеИмя = "Подсистема.СтандартныеПодсистемы.Подсистема.ЭлектроннаяЦифроваяПодпись";
	НовоеИмя  = "Подсистема.СтандартныеПодсистемы.Подсистема.ЭлектроннаяПодпись";
	ОбщегоНазначения.ДобавитьПереименование(Итог, "2.2.1.7", СтароеИмя, НовоеИмя, Библиотека);
	
	СтароеИмя = "Роль.ИспользованиеЭП";
	НовоеИмя  = "Роль.ИспользованиеЭлектроннойПодписиИШифрования";
	ОбщегоНазначения.ДобавитьПереименование(Итог, "2.3.1.10", СтароеИмя, НовоеИмя, Библиотека);
	
	СтароеИмя = "Роль.ИспользованиеЭлектроннойПодписиИШифрования";
	НовоеИмя  = "Роль.ДобавлениеИзменениеЭлектронныхПодписейИШифрование";
	ОбщегоНазначения.ДобавитьПереименование(Итог, "2.3.3.2", СтароеИмя, НовоеИмя, Библиотека);
	
КонецПроцедуры

// Определяет параметры работы клиента.
//
// Параметры:
//   Параметры - Структура - Все параметры работы клиента.
//
Процедура ПриДобавленииПараметровРаботыКлиента(Параметры) Экспорт
	
	Если ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		НастройкиПодсистемы = Новый Структура;
		НастройкиПодсистемы.Вставить("ПерсональныеНастройки", ЭлектроннаяПодпись.ПерсональныеНастройки());
		НастройкиПодсистемы.Вставить("ОбщиеНастройки",        ЭлектроннаяПодпись.ОбщиеНастройки());
		НастройкиПодсистемы = Новый ФиксированнаяСтруктура(НастройкиПодсистемы);
		Параметры.Вставить("ЭлектроннаяПодпись", НастройкиПодсистемы);
	КонецЕсли;
	
	Параметры.Вставить("ТипыПрограммЭлектроннойПодписи", ЭлектроннаяПодписьСлужебныйПовтИсп.ТипыПрограммЭлектроннойПодписи());
	
КонецПроцедуры

// Определить список справочников, доступных для загрузки с помощью подсистемы "Загрузка данных из файла".
//
// Параметры:
//  ЗагружаемыеСправочники - ТаблицаЗначений - список справочников, в которые возможна загрузка данных.
//      * ПолноеИмя          - Строка - полное имя справочника (как в метаданных).
//      * Представление      - Строка - представление справочника в списке выбора.
//      * ПрикладнаяЗагрузка - Булево - если Истина, значит справочник использует собственный алгоритм загрузки и
//                                      в модуле менеджера справочника определены функции.
//
Процедура ПриОпределенииСправочниковДляЗагрузкиДанных(ЗагружаемыеСправочники) Экспорт
	
	// Загрузка в справочник ПрограммыЭлектроннойПодписиИШифрования запрещена.
	СтрокаТаблицы = ЗагружаемыеСправочники.Найти(Метаданные.Справочники.ПрограммыЭлектроннойПодписиИШифрования.ПолноеИмя(), "ПолноеИмя");
	Если СтрокаТаблицы <> Неопределено Тогда 
		ЗагружаемыеСправочники.Удалить(СтрокаТаблицы);
	КонецЕсли;
	
	// Загрузка в справочник СертификатыКлючейЭлектроннойПодписиИШифрования запрещена.
	СтрокаТаблицы = ЗагружаемыеСправочники.Найти(Метаданные.Справочники.СертификатыКлючейЭлектроннойПодписиИШифрования.ПолноеИмя(), "ПолноеИмя");
	Если СтрокаТаблицы <> Неопределено Тогда 
		ЗагружаемыеСправочники.Удалить(СтрокаТаблицы);
	КонецЕсли;
	
КонецПроцедуры

// Определить объекты метаданных, в модулях менеджеров которых ограничивается возможность 
// редактирования реквизитов при групповом изменении.
//
// Параметры:
//   Объекты - Соответствие - в качестве ключа указать полное имя объекта метаданных,
//                            подключенного к подсистеме "Групповое изменение объектов". 
//                            Дополнительно в значении могут быть перечислены имена экспортных функций:
//                            "РеквизитыНеРедактируемыеВГрупповойОбработке",
//                            "РеквизитыРедактируемыеВГрупповойОбработке".
//                            Каждое имя должно начинаться с новой строки.
//                            Если указана пустая строка, значит в модуле менеджера определены обе функции.
//
Процедура ПриОпределенииОбъектовСРедактируемымиРеквизитами(Объекты) Экспорт
	Объекты.Вставить(Метаданные.Справочники.ПрограммыЭлектроннойПодписиИШифрования.ПолноеИмя(), "РеквизитыРедактируемыеВГрупповойОбработке");
	Объекты.Вставить(Метаданные.Справочники.СертификатыКлючейЭлектроннойПодписиИШифрования.ПолноеИмя(), "РеквизитыНеРедактируемыеВГрупповойОбработке");
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Прочие процедуры и функции.

// Только для внутреннего использования.
Процедура ОформитьСписокПодписей(Форма, ИмяСпискаПодписей) Экспорт
	
	Элемент = Форма.УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяСпискаПодписей);
	
	ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяСпискаПодписей + ".ПодписьВерна");
	ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = Ложь;
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ЦветТекста", ЦветаСтиля.ЦветОсобогоТекста);
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Возвращает менеджер криптографии (на сервере) для указанной программы.
//
// Параметры:
//  Операция       - Строка - если не пустая, то должна содержать одну из строк, которые определяют
//                   операцию для вставки в описание ошибки: Подписание, ПроверкаПодписи, Шифрование,
//                   Расшифровка, ПроверкаСертификата, ПолучениеСертификатов.
//
//  ПоказатьОшибку - Булево - если Истина, тогда будет вызвано исключение, содержащее описание ошибки.
//
//  ОписаниеОшибки - Строка - возвращаемое описание ошибки, когда функция возвратила значение Неопределено.
//                 - Структура - содержит ошибки обращения к программам, если возвращено Неопределено.
//                    * ОписаниеОшибки   - Строка - полное описание ошибки, когда оно возвращается строкой.
//                    * ЗаголовокОшибки  - Строка - заголовок ошибки, который соответствует операции.
//                    * ИмяКомпьютера    - Строка - имя компьютера при получении менеджера криптографии.
//                    * Описание         - Строка - описание общей ошибки.
//                    * Общая            - Булево - если Истина, то содержит описание ошибки для всех программ,
//                                                  иначе альтернативное описание массиву Ошибки.
//                    * КАдминистратору  - Булево - для исправления общей ошибки требуются права администратора.
//                    * Ошибки           - Массив - содержит структуры описания ошибок программ со свойствами:
//                         * Программа       - СправочникСсылка.ПрограммыЭлектроннойПодписиИШифрования.
//                         * Описание        - Строка - содержит представление ошибки.
//                         * ИзИсключения    - Булево - описание содержит краткое представление информации об ошибке.
//                         * НеУказанПуть    - Булево - описание содержит ошибку о неуказанном пути для ОС Linux.
//                         * КАдминистратору - Булево - для исправления ошибки требуются права администратора.
//
//  Программа      - Неопределено - возвращает менеджер криптографии первой
//                   программы из справочника для которой удалось его создать.
//                 - СправочникСсылка.ПрограммыЭлектроннойПодписиИШифрования - программа
//                   для которой нужно создать и вернуть менеджер криптографии.
//
// Возвращаемое значение:
//   МенеджерКриптографии - менеджер криптографии.
//   Неопределено - произошла ошибка, описание которой в параметре ОписаниеОшибки.
//
Функция МенеджерКриптографии(Операция, ПоказатьОшибку = Истина, ОписаниеОшибки = "", Программа = Неопределено) Экспорт
	
	ИмяКомпьютера = ИмяКомпьютера();
	
	Ошибки = Новый Массив;
	Менеджер = НовыйМенеджерКриптографии(Программа, Ошибки, ИмяКомпьютера);
	
	Если Менеджер <> Неопределено Тогда
		Возврат Менеджер;
	КонецЕсли;
	
	Если Операция = "Подписание" Тогда
		ЗаголовокОшибки = НСтр("ru = 'Не удалось подписать данные на сервере %1 по причине:'");
		
	ИначеЕсли Операция = "ПроверкаПодписи" Тогда
		ЗаголовокОшибки = НСтр("ru = 'Не удалось проверить подпись на сервере %1 по причине:'");
		
	ИначеЕсли Операция = "Шифрование" Тогда
		ЗаголовокОшибки = НСтр("ru = 'Не удалось зашифровать данные на сервере %1 по причине:'");
		
	ИначеЕсли Операция = "Расшифровка" Тогда
		ЗаголовокОшибки = НСтр("ru = 'Не удалось расшифровать данные на сервере %1 по причине:'");
		
	ИначеЕсли Операция = "ПроверкаСертификата" Тогда
		ЗаголовокОшибки = НСтр("ru = 'Не удалось проверить сертификат на сервере %1 по причине:'");
		
	ИначеЕсли Операция = "ПолучениеСертификатов" Тогда
		ЗаголовокОшибки = НСтр("ru = 'Не удалось получить сертификаты на сервере %1 по причине:'");
		
	ИначеЕсли Операция <> "" Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Ошибка в функции МенеджерКриптографии.
			           |Неверное значение параметра Операция ""%1"".'"), Операция);
		
	ИначеЕсли ТипЗнч(ОписаниеОшибки) = Тип("Структура")
	        И ОписаниеОшибки.Свойство("ЗаголовокОшибки") Тогда
		
		ЗаголовокОшибки = ОписаниеОшибки.ЗаголовокОшибки;
	Иначе
		ЗаголовокОшибки = НСтр("ru = 'Не удалось выполнить операцию на сервере %1 по причине:'");
	КонецЕсли;
	
	ЗаголовокОшибки = СтрЗаменить(ЗаголовокОшибки, "%1", ИмяКомпьютера);
	
	СвойстваОшибки = Новый Структура;
	СвойстваОшибки.Вставить("ЗаголовокОшибки", ЗаголовокОшибки);
	СвойстваОшибки.Вставить("ИмяКомпьютера", ИмяКомпьютера);
	СвойстваОшибки.Вставить("КАдминистратору", Истина);
	СвойстваОшибки.Вставить("Общая", Ложь);
	СвойстваОшибки.Вставить("Ошибки", Ошибки);
	
	Если Ошибки.Количество() = 0 Тогда
		ТекстОшибки = НСтр("ru = 'Не предусмотрено использование ни одной программы.'");
		СвойстваОшибки.Общая = Истина;
		СвойстваОшибки.Вставить("Инструкция", Истина);
		СвойстваОшибки.Вставить("НастройкаПрограмм", Истина);
		
	ИначеЕсли ЗначениеЗаполнено(Программа) Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Программа %1 не доступна или не установлена.'"), Программа);
	Иначе
		ТекстОшибки = НСтр("ru = 'Ни одна из программ не доступна или не установлена.'");
	КонецЕсли;
	СвойстваОшибки.Вставить("Описание", ТекстОшибки);
	
	Если Не Пользователи.ЭтоПолноправныйПользователь(,, Ложь) Тогда
		ТекстОшибки = ТекстОшибки + Символы.ПС + Символы.ПС
			+ НСтр("ru = 'Обратитесь к администратору.'");
	КонецЕсли;
	
	СвойстваОшибки.Вставить("ОписаниеОшибки", ЗаголовокОшибки + Символы.ПС + ТекстОшибки);
	
	Если ТипЗнч(ОписаниеОшибки) = Тип("Структура") Тогда
		ОписаниеОшибки = СвойстваОшибки;
	Иначе
		ОписаниеОшибки = СвойстваОшибки.ОписаниеОшибки;
	КонецЕсли;
	
	Если ПоказатьОшибку Тогда
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Находит сертификат на компьютере по строке отпечатка.
//
// Параметры:
//   Отпечаток              - Строка - Base64 кодированный отпечаток сертификата.
//   ТолькоВЛичномХранилище - Булево - если Истина, тогда искать в личном хранилище, иначе везде.
//
// Возвращаемое значение:
//   СертификатКриптографии - сертификат электронной подписи и шифрования.
//   Неопределено - сертификат не найден.
//
Функция ПолучитьСертификатПоОтпечатку(Отпечаток, ТолькоВЛичномХранилище,
			ПоказатьОшибку = Истина, Программа = Неопределено, ОписаниеОшибки = "") Экспорт
	
	МенеджерКриптографии = МенеджерКриптографии("ПолучениеСертификатов",
		ПоказатьОшибку, ОписаниеОшибки, Программа);
	
	Если МенеджерКриптографии = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ТипХранилища = ЭлектроннаяПодписьСлужебныйКлиентСервер.ТипХранилищаДляПоискаСертификата(ТолькоВЛичномХранилище);
	
	Попытка
		ДвоичныеДанныеОтпечатка = Base64Значение(Отпечаток);
	Исключение
		Если ПоказатьОшибку Тогда
			ВызватьИсключение;
		КонецЕсли;
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ПредставлениеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
	КонецПопытки;
	
	Если Не ЗначениеЗаполнено(ПредставлениеОшибки) Тогда
		Попытка
			ХранилищеСертификатовКриптографии = МенеджерКриптографии.ПолучитьХранилищеСертификатов(ТипХранилища);
		Исключение
			Если ПоказатьОшибку Тогда
				ВызватьИсключение;
			КонецЕсли;
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			ПредставлениеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
		КонецПопытки;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ПредставлениеОшибки) Тогда
		Попытка
			Сертификат = ХранилищеСертификатовКриптографии.НайтиПоОтпечатку(ДвоичныеДанныеОтпечатка);
		Исключение
			Если ПоказатьОшибку Тогда
				ВызватьИсключение;
			КонецЕсли;
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			ПредставлениеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
		КонецПопытки;
	КонецЕсли;
	
	Если ТипЗнч(Сертификат) = Тип("СертификатКриптографии") Тогда
		Возврат Сертификат;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПредставлениеОшибки) Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Сертификат не найден на сервере по причине:
			           |%1
			           |'"),
			ПредставлениеОшибки);
	Иначе
		ТекстОшибки = НСтр("ru = 'Сертификат не найден на сервере.'");
	КонецЕсли;
		
	Если Не Пользователи.ЭтоПолноправныйПользователь(,, Ложь) Тогда
		ТекстОшибки = ТекстОшибки + Символы.ПС + НСтр("ru = 'Обратитесь к администратору.'")
	КонецЕсли;
	
	ТекстОшибки = СокрП(ТекстОшибки);
	
	Если ТипЗнч(ОписаниеОшибки) = Тип("Структура") Тогда
		ОписаниеОшибки = Новый Структура;
		ОписаниеОшибки.Вставить("ОписаниеОшибки", ТекстОшибки);
	Иначе
		ОписаниеОшибки = ПредставлениеОшибки;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Сохраняет настройки текущего пользователя для работы с электронной подписью.
Процедура СохранитьПерсональныеНастройки(ПерсональныеНастройки) Экспорт
	
	КлючПодсистемы = КлючХраненияНастроек();
	
	Для Каждого КлючИЗначение Из ПерсональныеНастройки Цикл
		ОбщегоНазначения.ХранилищеОбщихНастроекСохранить(КлючПодсистемы, КлючИЗначение.Ключ,
			КлючИЗначение.Значение);
	КонецЦикла;
	
КонецПроцедуры

// Ключ, который используется для хранения настроек подсистемы.
Функция КлючХраненияНастроек() Экспорт
	
	Возврат "ЭЦП"; // Не заменять на "ЭП". Используется для обратной совместимости.
	
КонецФункции

// Только для внутреннего использования.
Процедура ПередНачаломРедактированияСертификатаКлюча(Ссылка, Сертификат, ПараметрыРеквизитов) Экспорт
	
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("ИмяРеквизита",       Новый ОписаниеТипов("Строка"));
	Таблица.Колонки.Добавить("ТолькоПросмотр",     Новый ОписаниеТипов("Булево"));
	Таблица.Колонки.Добавить("ПроверкаЗаполнения", Новый ОписаниеТипов("Булево"));
	Таблица.Колонки.Добавить("Видимость",          Новый ОписаниеТипов("Булево"));
	Таблица.Колонки.Добавить("ЗначениеЗаполнения");
	
	ЭлектроннаяПодписьПереопределяемый.ПередНачаломРедактированияСертификатаКлюча(Ссылка, Сертификат, Таблица);
	
	ПараметрыРеквизитов = Новый Структура;
	
	Для каждого Строка Из Таблица Цикл
		Параметры = Новый Структура;
		Параметры.Вставить("ТолькоПросмотр",     Строка.ТолькоПросмотр);
		Параметры.Вставить("ПроверкаЗаполнения", Строка.ПроверкаЗаполнения);
		Параметры.Вставить("Видимость",          Строка.Видимость);
		Параметры.Вставить("ЗначениеЗаполнения", Строка.ЗначениеЗаполнения);
		ПараметрыРеквизитов.Вставить(Строка.ИмяРеквизита, Параметры);
	КонецЦикла;
	
КонецПроцедуры

// Только для внутреннего использования.
Процедура ПроверитьУникальностьПредставления(Представление, СертификатСсылка, Поле, Отказ) Экспорт
	
	Если Не ЗначениеЗаполнено(Представление) Тогда
		Возврат;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка",       СертификатСсылка);
	Запрос.УстановитьПараметр("Наименование", Представление);
	
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ИСТИНА КАК ЗначениеИстина
	|ИЗ
	|	Справочник.СертификатыКлючейЭлектроннойПодписиИШифрования КАК Сертификаты
	|ГДЕ
	|	Сертификаты.Ссылка <> &Ссылка
	|	И Сертификаты.Наименование = &Наименование";
	
	Если Не Запрос.Выполнить().Пустой() Тогда
		ТекстСообщения = НСтр("ru = 'Сертификат с таким представлением уже существует.'");
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,, Поле,, Отказ);
	КонецЕсли;
	
КонецПроцедуры


// Только для внутреннего использования.
Процедура ОбновитьСписокСертификатов(Сертификаты, СвойстваСертификатовНаКлиенте, КромеУжеДобавленных,
				Личные, Ошибка, БезОтбора) Экспорт
	
	ТаблицаСвойствСертификатов = Новый ТаблицаЗначений;
	ТаблицаСвойствСертификатов.Колонки.Добавить("Отпечаток", Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(255)));
	ТаблицаСвойствСертификатов.Колонки.Добавить("КемВыдан");
	ТаблицаСвойствСертификатов.Колонки.Добавить("Представление");
	ТаблицаСвойствСертификатов.Колонки.Добавить("НаКлиенте",        Новый ОписаниеТипов("Булево"));
	ТаблицаСвойствСертификатов.Колонки.Добавить("НаСервере",        Новый ОписаниеТипов("Булево"));
	ТаблицаСвойствСертификатов.Колонки.Добавить("ЭтоЗаявление",     Новый ОписаниеТипов("Булево"));
	ТаблицаСвойствСертификатов.Колонки.Добавить("ВОблачномСервисе", Новый ОписаниеТипов("Булево"));
	
	Для Каждого СвойстваСертификата Из СвойстваСертификатовНаКлиенте Цикл
		НоваяСтрока = ТаблицаСвойствСертификатов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СвойстваСертификата);
		НоваяСтрока.НаКлиенте = Истина;
	КонецЦикла;
	
	ТаблицаСвойствСертификатов.Индексы.Добавить("Отпечаток");
	
	Если ЭлектроннаяПодпись.ОбщиеНастройки().СоздаватьЭлектронныеПодписиНаСервере Тогда
		
		МенеджерКриптографии = МенеджерКриптографии("ПолучениеСертификатов", Ложь, Ошибка);
		Если МенеджерКриптографии <> Неопределено Тогда
			
			МассивСертификатов = МенеджерКриптографии.ПолучитьХранилищеСертификатов(
				ТипХранилищаСертификатовКриптографии.ПерсональныеСертификаты).ПолучитьВсе();
			
			Если Не Личные Тогда
				Массив = МенеджерКриптографии.ПолучитьХранилищеСертификатов(
					ТипХранилищаСертификатовКриптографии.СертификатыПолучателей).ПолучитьВсе();
				
				Для каждого Сертификат Из Массив Цикл
					МассивСертификатов.Добавить(Сертификат);
				КонецЦикла;
			КонецЕсли;
			
			ЭлектроннаяПодписьСлужебныйКлиентСервер.ДобавитьСвойстваСертификатов(
				ТаблицаСвойствСертификатов, МассивСертификатов, БезОтбора);
		КонецЕсли;
	КонецЕсли;
	
	Если ИспользоватьЭлектроннуюПодписьВМоделиСервиса() Тогда
		МодульЭлектроннаяПодписьВМоделиСервисаКлиентСервер = ОбщегоНазначения.ОбщийМодуль("ЭлектроннаяПодписьВМоделиСервисаКлиентСервер");
		Если МодульЭлектроннаяПодписьВМоделиСервисаКлиентСервер.ИспользованиеВозможно() Тогда
			
			МассивСертификатов = Новый Массив;
			МодульХранилищеСертификатов = ОбщегоНазначения.ОбщийМодуль("ХранилищеСертификатов");
			ПерсональныеСертификаты = МодульХранилищеСертификатов.Получить("ПерсональныеСертификаты");
			Для Каждого ПерсональныйСертификат Из ПерсональныеСертификаты Цикл
				МассивСертификатов.Добавить(ПерсональныйСертификат);
			КонецЦикла;
			
			Если Не Личные Тогда
				СертификатыПолучателей = МодульХранилищеСертификатов.Получить("СертификатыПолучателей");
				Для Каждого СертификатПолучателя Из СертификатыПолучателей Цикл
					МассивСертификатов.Добавить(СертификатПолучателя);
				КонецЦикла;
			КонецЕсли;
			
			ЭлектроннаяПодписьСлужебныйКлиентСервер.ДобавитьСвойстваСертификатов(
				ТаблицаСвойствСертификатов, МассивСертификатов, БезОтбора, , Истина);
		КонецЕсли;
	КонецЕсли;	
	
	ОбработатьДобавленныеСертификаты(ТаблицаСвойствСертификатов, Не БезОтбора И КромеУжеДобавленных);
	
	ТаблицаСвойствСертификатов.Индексы.Добавить("Представление");
	ТаблицаСвойствСертификатов.Сортировать("Представление Возр");
	
	ОбработанныеСтроки  = Новый Соответствие;
	Индекс = 0;
	Отбор = Новый Структура("Отпечаток", "");
	
	Для каждого СвойстваСертификата Из ТаблицаСвойствСертификатов Цикл
		Отбор.Отпечаток = СвойстваСертификата.Отпечаток;
		Строки = Сертификаты.НайтиСтроки(Отбор);
		Если Строки.Количество() = 0 Тогда
			Если Сертификаты.Количество()-1 < Индекс Тогда
				Строка = Сертификаты.Добавить();
			Иначе
				Строка = Сертификаты.Вставить(Индекс);
			КонецЕсли;
		Иначе
			Строка = Строки[0];
			ИндексСтроки = Сертификаты.Индекс(Строка);
			Если ИндексСтроки <> Индекс Тогда
				Сертификаты.Сдвинуть(ИндексСтроки, Индекс - ИндексСтроки);
			КонецЕсли;
		КонецЕсли;
		// Обновление только измененных значений, чтобы таблица формы не обновлялась лишний раз.
		ОбновитьЗначение(Строка.Отпечаток,          СвойстваСертификата.Отпечаток);
		ОбновитьЗначение(Строка.Представление,      СвойстваСертификата.Представление);
		ОбновитьЗначение(Строка.КемВыдан,           СвойстваСертификата.КемВыдан);
		ОбновитьЗначение(Строка.НаКлиенте,          СвойстваСертификата.НаКлиенте);
		ОбновитьЗначение(Строка.НаСервере,          СвойстваСертификата.НаСервере);
		ОбновитьЗначение(Строка.ЭтоЗаявление,       СвойстваСертификата.ЭтоЗаявление);
		ОбновитьЗначение(Строка.ВОблачномСервисе,   СвойстваСертификата.ВОблачномСервисе);
		ОбработанныеСтроки.Вставить(Строка, Истина);
		Индекс = Индекс + 1;
	КонецЦикла;
	
	Индекс = Сертификаты.Количество()-1;
	Пока Индекс >=0 Цикл
		Строка = Сертификаты.Получить(Индекс);
		Если ОбработанныеСтроки.Получить(Строка) = Неопределено Тогда
			Сертификаты.Удалить(Индекс);
		КонецЕсли;
		Индекс = Индекс-1;
	КонецЦикла;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции управляемых форм.

// Только для внутреннего использования.
Процедура НастроитьФормуПодписанияШифрованияРасшифровки(Форма, Шифрование = Ложь, Расшифровка = Ложь) Экспорт
	
	Элементы  = Форма.Элементы;
	Параметры = Форма.Параметры;
	
	Форма.Заголовок = Параметры.Операция;
	
	Форма.ВыполнятьНаСервере = Параметры.ВыполнятьНаСервере;
	
	Если Шифрование Тогда
		Если Форма.УказанНаборСертификатов Тогда
			Форма.БезПодтверждения = Параметры.БезПодтверждения;
		КонецЕсли;
	Иначе
		Если ТипЗнч(Параметры.ОтборСертификатов) = Тип("Массив") Тогда
			Форма.ОтборСертификатов.ЗагрузитьЗначения(Параметры.ОтборСертификатов);
		КонецЕсли;
		Форма.БезПодтверждения = Параметры.БезПодтверждения;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Параметры.ЗаголовокДанных) Тогда
		Элементы.ПредставлениеДанных.Заголовок = Параметры.ЗаголовокДанных;
	Иначе
		Элементы.ПредставлениеДанных.ПоложениеЗаголовка = ПоложениеЗаголовкаЭлементаФормы.Нет;
	КонецЕсли;
	
	Форма.ПредставлениеДанных = Параметры.ПредставлениеДанных;
	Элементы.ПредставлениеДанных.Гиперссылка = Параметры.ПредставлениеДанныхОткрывается;
	
	Если Не ЗначениеЗаполнено(Форма.ПредставлениеДанных) Тогда
		Элементы.ПредставлениеДанных.Видимость = Ложь;
	КонецЕсли;
	
	Если Расшифровка Тогда
		ЗаполнитьОтборОтпечатков(Форма);
	ИначеЕсли Не Шифрование Тогда // Подписание
		Элементы.Комментарий.Видимость = Параметры.ПоказатьКомментарий И Не Форма.БезПодтверждения;
	КонецЕсли;
	
	ЗаполнитьСуществующиеСертификатыПользователя(Форма.СертификатСписокВыбора,
		Параметры.ОтпечаткиСертификатовНаКлиенте, Форма.ОтборСертификатов, Форма.ОтборОтпечатков);
	
	Сертификат = Неопределено;
	
	Если Расшифровка Тогда
		Для каждого ЭлементСписка Из Форма.СертификатСписокВыбора Цикл
			Если ТипЗнч(ЭлементСписка.Значение) = Тип("Строка") Тогда
				Продолжить;
			КонецЕсли;
			Сертификат = ЭлементСписка.Значение;
			Прервать;
		КонецЦикла;
		
	ИначеЕсли ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Если Шифрование Тогда
			Сертификат = ХранилищеОбщихНастроек.Загрузить("Криптография", "СертификатДляШифрования");
		Иначе
			Сертификат = ХранилищеОбщихНастроек.Загрузить("Криптография", "СертификатДляПодписания");
		КонецЕсли;
	КонецЕсли;
	
	Если Форма.ОтборСертификатов.Количество() > 1 Тогда
		Сертификат = Неопределено;
	ИначеЕсли Форма.ОтборСертификатов.Количество() = 1 Тогда
		Сертификат = Форма.ОтборСертификатов[0].Значение;
	КонецЕсли;
	
	Если Не (Шифрование И Форма.УказанНаборСертификатов) Тогда
		Форма.Сертификат = Сертификат;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Форма.Сертификат)
	   И ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Форма.Сертификат, "Ссылка") <> Форма.Сертификат Тогда
		
		Форма.Сертификат = Неопределено;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Форма.Сертификат) Тогда
		Если Шифрование Тогда
			Элементы.СертификатыШифрования.АктивизироватьПоУмолчанию = Истина;
		Иначе
			Элементы.Пароль.АктивизироватьПоУмолчанию = Истина;
		КонецЕсли;
	Иначе
		Если Не (Шифрование И Форма.УказанНаборСертификатов) Тогда
			Элементы.Сертификат.АктивизироватьПоУмолчанию = Истина;
		КонецЕсли;
	КонецЕсли;
	
	ЗаполнитьДополнительныеСвойстваСертификата(Форма);
	
	Форма.МенеджерКриптографииНаСервереОписаниеОшибки = Новый Структура;
	Если ЭлектроннаяПодписьКлиентСервер.ОбщиеНастройки().СоздаватьЭлектронныеПодписиНаСервере Тогда
		МенеджерКриптографии("ПолучениеСертификатов",
			Ложь, Форма.МенеджерКриптографииНаСервереОписаниеОшибки);
	КонецЕсли;
	
	Если Не Шифрование Тогда
		ЭлектроннаяПодписьПереопределяемый.ПередНачаломОперации(?(Расшифровка, "Расшифровка", "Подписание"),
			Параметры.ПараметрыДополнительныхДействий, Форма.ВыходныеПараметрыДополнительныхДействий);
	КонецЕсли;
	
КонецПроцедуры

// Только для внутреннего использования.
Процедура СертификатПриИзмененииНаСервере(Форма, ОтпечаткиСертификатовНаКлиенте, Шифрование = Ложь, Расшифровка = Ложь) Экспорт
	
	Если Форма.ОтборСертификатов.Количество() = 0
	   И ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		
		Если Шифрование Тогда
			ХранилищеОбщихНастроек.Сохранить("Криптография", "СертификатДляШифрования", Форма.Сертификат);
		ИначеЕсли Не Расшифровка Тогда
			ХранилищеОбщихНастроек.Сохранить("Криптография", "СертификатДляПодписания", Форма.Сертификат);
		КонецЕсли;
	КонецЕсли;
	
	ЗаполнитьСуществующиеСертификатыПользователя(Форма.СертификатСписокВыбора,
		ОтпечаткиСертификатовНаКлиенте, Форма.ОтборСертификатов, Форма.ОтборОтпечатков);
	
	ЗаполнитьДополнительныеСвойстваСертификата(Форма);
	
КонецПроцедуры

// Только для внутреннего использования.
Функция СохраненныеСвойстваСертификата(Отпечаток, Адрес, ПараметрыРеквизитов, ДляШифрования = Ложь) Экспорт
	
	СохраненныеСвойства = Новый Структура;
	СохраненныеСвойства.Вставить("Ссылка");
	СохраненныеСвойства.Вставить("Наименование");
	СохраненныеСвойства.Вставить("Пользователь");
	СохраненныеСвойства.Вставить("Организация");
	СохраненныеСвойства.Вставить("УсиленнаяЗащитаЗакрытогоКлюча");
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Отпечаток", Отпечаток);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Сертификаты.Ссылка КАК Ссылка,
	|	Сертификаты.Наименование КАК Наименование,
	|	Сертификаты.Пользователь,
	|	Сертификаты.Организация,
	|	Сертификаты.УсиленнаяЗащитаЗакрытогоКлюча,
	|	Сертификаты.ДанныеСертификата
	|ИЗ
	|	Справочник.СертификатыКлючейЭлектроннойПодписиИШифрования КАК Сертификаты
	|ГДЕ
	|	Сертификаты.Отпечаток = &Отпечаток";
	
	СертификатКриптографии = Новый СертификатКриптографии(ПолучитьИзВременногоХранилища(Адрес));
	
	ЗначенияЗаполнения = ПараметрыРеквизитов;
	ПараметрыРеквизитов = Неопределено; // Заполняется в процедуре ПередНачаломРедактированияСертификатаКлюча.
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		ЗаполнитьЗначенияСвойств(СохраненныеСвойства, Выборка);
	Иначе
		СохраненныеСвойства.Ссылка = Справочники.СертификатыКлючейЭлектроннойПодписиИШифрования.ПустаяСсылка();
		
		Если ТипЗнч(ЗначенияЗаполнения) = Тип("Структура")
		   И ЗначенияЗаполнения.Свойство("Организация")
		   И ЗначениеЗаполнено(ЗначенияЗаполнения.Организация) Тогда
			
			СохраненныеСвойства.Организация = ЗначенияЗаполнения.Организация;
			
		ИначеЕсли Не Метаданные.ОпределяемыеТипы.Организация.Тип.СодержитТип(Тип("Строка")) Тогда
			ПолноеИмя = Метаданные.НайтиПоТипу(Метаданные.ОпределяемыеТипы.Организация.Тип.Типы()[0]).ПолноеИмя();
			ИмяСправочникаОрганизации = "Справочники." + СтрРазделить(ПолноеИмя, ".")[1];
			МодульОрганизации = ОбщегоНазначения.ОбщийМодуль(ИмяСправочникаОрганизации);
			Если Не ДляШифрования Тогда
				СохраненныеСвойства.Организация = МодульОрганизации.ОрганизацияПоУмолчанию();
			КонецЕсли;
		КонецЕсли;
		СохраненныеСвойства.Наименование = ЭлектроннаяПодписьКлиентСервер.ПредставлениеСертификата(СертификатКриптографии);
		Если Не ДляШифрования Тогда
			СохраненныеСвойства.Пользователь = ПользователиКлиентСервер.ТекущийПользователь();
		КонецЕсли;
	КонецЕсли;
	
	ПередНачаломРедактированияСертификатаКлюча(
		СохраненныеСвойства.Ссылка, СертификатКриптографии, ПараметрыРеквизитов);
	
	Если Не ЗначениеЗаполнено(СохраненныеСвойства.Ссылка) Тогда
		ЗаполнитьРеквизит(СохраненныеСвойства, ПараметрыРеквизитов, "Наименование");
		ЗаполнитьРеквизит(СохраненныеСвойства, ПараметрыРеквизитов, "Пользователь");
		ЗаполнитьРеквизит(СохраненныеСвойства, ПараметрыРеквизитов, "Организация");
		ЗаполнитьРеквизит(СохраненныеСвойства, ПараметрыРеквизитов, "УсиленнаяЗащитаЗакрытогоКлюча");
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(СохраненныеСвойства.Ссылка)
	   И ТипЗнч(ЗначенияЗаполнения) = Тип("Структура")
	   И ЗначенияЗаполнения.Свойство("Организация")
	   И ЗначениеЗаполнено(ЗначенияЗаполнения.Организация)
	   И Не ПараметрыРеквизитов.Свойство("Организация") Тогда
	
		Параметры = Новый Структура;
		Параметры.Вставить("ТолькоПросмотр",     Истина);
		Параметры.Вставить("ПроверкаЗаполнения", Ложь);
		Параметры.Вставить("Видимость",          Истина);
		ПараметрыРеквизитов.Вставить("Организация", Параметры);
	КонецЕсли;
	
	Возврат СохраненныеСвойства;
	
КонецФункции

// Только для внутреннего использования.
Процедура ЗаписатьСертификатВСправочник(Форма, Программа = Неопределено, ДляШифрования = Ложь) Экспорт
	
	ДополнительныеПараметры = Новый Структура;
	ДополнительныеПараметры.Вставить("Наименование", Форма.СертификатНаименование);
	ДополнительныеПараметры.Вставить("Пользователь", Форма.СертификатПользователь);
	ДополнительныеПараметры.Вставить("Организация",  Форма.СертификатОрганизация);
	
	Если Не ДляШифрования Тогда
		ДополнительныеПараметры.Вставить("Программа", Программа);
		ДополнительныеПараметры.Вставить("УсиленнаяЗащитаЗакрытогоКлюча",
			Форма.СертификатУсиленнаяЗащитаЗакрытогоКлюча);
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(Форма.Сертификат) Тогда
		ПропускаемыеРеквизиты = Новый Соответствие;
		ПропускаемыеРеквизиты.Вставить("Ссылка",       Истина);
		ПропускаемыеРеквизиты.Вставить("Наименование", Истина);
		ПропускаемыеРеквизиты.Вставить("Организация",  Истина);
		ПропускаемыеРеквизиты.Вставить("УсиленнаяЗащитаЗакрытогоКлюча", Истина);
		Если Не ДляШифрования И Форма.ЛичныйСписокПриДобавлении Тогда
			ПропускаемыеРеквизиты.Вставить("Пользователь",  Истина);
		КонецЕсли;
		Для каждого КлючИЗначение Из Форма.СертификатПараметрыРеквизитов Цикл
			ИмяРеквизита = КлючИЗначение.Ключ;
			Свойства     = КлючИЗначение.Значение;
			Если ПропускаемыеРеквизиты.Получить(ИмяРеквизита) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			Если Свойства.ЗначениеЗаполнения = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			ДополнительныеПараметры.Вставить(ИмяРеквизита, Свойства.ЗначениеЗаполнения);
		КонецЦикла;
	КонецЕсли;
	
	Форма.Сертификат = ЭлектроннаяПодпись.ЗаписатьСертификатВСправочник(Форма.СертификатАдрес,
		ДополнительныеПараметры);
	
КонецПроцедуры

// Только для внутреннего использования.
Процедура УстановитьУсловноеОформлениеСпискаСертификатов(Список, ИсключитьЗаявления = Ложь) Экспорт
	
	ЭлементУсловногоОформления = Список.УсловноеОформление.Элементы.Добавить();
	
	ЭлементЦветаОформления = ЭлементУсловногоОформления.Оформление.Элементы.Найти("TextColor");
	ЭлементЦветаОформления.Значение = Метаданные.ЭлементыСтиля.ТекстЗапрещеннойЯчейкиЦвет.Значение;
	ЭлементЦветаОформления.Использование = Истина;
	
	Если ИсключитьЗаявления Тогда
		СписокСостояний = Новый СписокЗначений;
		СписокСостояний.Добавить(Перечисления.СостоянияЗаявленияНаВыпускСертификата.ПустаяСсылка());
		СписокСостояний.Добавить(Перечисления.СостоянияЗаявленияНаВыпускСертификата.Исполнено);
		
		ЭлементОтбораДанных = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		ЭлементОтбораДанных.ЛевоеЗначение  = Новый ПолеКомпоновкиДанных("СостояниеЗаявления");
		ЭлементОтбораДанных.ВидСравнения   = ВидСравненияКомпоновкиДанных.ВСписке;
		ЭлементОтбораДанных.ПравоеЗначение = СписокСостояний;
		ЭлементОтбораДанных.Использование  = Истина;
	КонецЕсли;
	
	ГруппаЭлементовОтбора = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
	ГруппаЭлементовОтбора.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаНе;
	
	ЭлементОтбораДанных = ГруппаЭлементовОтбора.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ЭлементОтбораДанных.ЛевоеЗначение  = Новый ПолеКомпоновкиДанных("Отозван");
	ЭлементОтбораДанных.ВидСравнения   = ВидСравненияКомпоновкиДанных.Равно;
	ЭлементОтбораДанных.ПравоеЗначение = Ложь;
	ЭлементОтбораДанных.Использование  = Истина;
	
	ЭлементОтбораДанных = ГруппаЭлементовОтбора.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ЭлементОтбораДанных.ЛевоеЗначение  = Новый ПолеКомпоновкиДанных("ДействителенДо");
	ЭлементОтбораДанных.ВидСравнения   = ВидСравненияКомпоновкиДанных.Больше;
	ЭлементОтбораДанных.ПравоеЗначение = Новый СтандартнаяДатаНачала(ВариантСтандартнойДатыНачала.НачалоЭтогоДня);
	ЭлементОтбораДанных.Использование  = Истина;
	
	ЭлементОформляемогоПоля = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ЭлементОформляемогоПоля.Поле = Новый ПолеКомпоновкиДанных("");
	ЭлементОформляемогоПоля.Использование = Истина;
	
КонецПроцедуры

// Только для внутреннего использования.
Функция СертификатИзДвоичныхДанных(ДанныеСертификата) Экспорт
	
	Если ТипЗнч(ДанныеСертификата) <> Тип("ДвоичныеДанные") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Попытка
		СертификатКриптографии = Новый СертификатКриптографии(ДанныеСертификата);
	Исключение
		СертификатКриптографии = Неопределено;
	КонецПопытки;
	
	Если СертификатКриптографии <> Неопределено Тогда
		Возврат СертификатКриптографии;
	КонецЕсли;
	
	ПолноеИмяВременногоФайла = ПолучитьИмяВременногоФайла("cer");
	ДанныеСертификата.Записать(ПолноеИмяВременногоФайла);
	Текст = Новый ТекстовыйДокумент;
	Текст.Прочитать(ПолноеИмяВременногоФайла);
	
	Попытка
		УдалитьФайлы(ПолноеИмяВременногоФайла);
	Исключение
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'Электронная подпись.Удаление временного файла'",
				ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка, , ,
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	Если Текст.КоличествоСтрок() < 3
	 Или Текст.ПолучитьСтроку(1) <> "-----BEGIN CERTIFICATE-----"
	 Или Текст.ПолучитьСтроку(Текст.КоличествоСтрок()) <> "-----END CERTIFICATE-----" Тогда
		
		Возврат Неопределено;
	КонецЕсли;
	
	Текст.УдалитьСтроку(1);
	Текст.УдалитьСтроку(Текст.КоличествоСтрок());
	СтрокаBase64 = Текст.ПолучитьТекст();
	
	Попытка
		ДанныеСертификата = Base64Значение(СтрокаBase64);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
	Если ТипЗнч(ДанныеСертификата) <> Тип("ДвоичныеДанные") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Попытка
		СертификатКриптографии = Новый СертификатКриптографии(ДанныеСертификата);
	Исключение
		СертификатКриптографии = Неопределено;
	КонецПопытки;
	
	Возврат СертификатКриптографии;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Обновление информационной базы.

// Обработчик конвертации данных при переходе на поддержку использования
// нескольких программ электронной подписи и шифрования в одной ИБ.
//
Процедура ПеренестиНастройкиМенеджераКриптографии() Экспорт
	
	ПрограммаОбъект = СтараяПрограмма();
	Программа = Неопределено;
	
	НачатьТранзакцию();
	Попытка
		Если ПрограммаОбъект <> Неопределено Тогда
			Если Не ОбщегоНазначения.ЭтоПодчиненныйУзелРИБ() Тогда
				ОбновлениеИнформационнойБазы.ЗаписатьДанные(ПрограммаОбъект);
			КонецЕсли;
			Программа = ПрограммаОбъект.Ссылка;
		КонецЕсли;
		
		Если Константы.ИспользоватьЭлектронныеПодписи.Получить()
		   И Не Константы.ИспользоватьШифрование.Получить() Тогда
		
			МенеджерЗначения = Константы.ИспользоватьШифрование.СоздатьМенеджерЗначения();
			МенеджерЗначения.Значение = Истина;
			ОбновлениеИнформационнойБазы.ЗаписатьДанные(МенеджерЗначения);
		КонецЕсли;
		
		ОчиститьКонстанту(Константы.УдалитьПровайдерЭП);
		ОчиститьКонстанту(Константы.УдалитьТипПровайдераЭП);
		ОчиститьКонстанту(Константы.УдалитьАлгоритмПодписи);
		ОчиститьКонстанту(Константы.УдалитьАлгоритмХеширования);
		ОчиститьКонстанту(Константы.УдалитьАлгоритмШифрования);
		ОбработатьПутиНаСерверахLinux(Программа);
		ОбработатьПутиНаКлиентахLinux(Программа);
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Работа с XMLDSig

// Подписывает сообщение, подставляя в шаблон SOAP данные подписи.
//
// Параметры:
//  КонвертSOAP               - Строка - шаблон формируемого сообщения в формате SOAP
//  ДанныеАлгоритмаПодписания - Структура:
//     XPathПодписываемыйТег   - Строка - запрос для получения тега подписи.
//     XPathSignedInfo         - Строка - запрос для получения тега подписываемой информации.
//     OIDАлгоритмаХеширования - Строка - идентификатор алгоритма хеширования.
//     ИмяАлгоритмаПодписи     - Строка - имя алгоритма подписи.
//  СертификатКриптографии     - СертификатКриптографии -  используемый сертификат криптографии.
//  МенеджерКриптографии       - МенеджерКриптографии - используемый менеджер криптографии.
// 
// Возвращаемое значение:
//  Строка - шаблон SOAP, со вставленными данными подписи.
//
Функция Подписать(Знач КонвертSOAP, ДанныеАлгоритмаПодписания, СертификатКриптографии, МенеджерКриптографии) Экспорт
	
	XPathПодписываемыйТег   = ДанныеАлгоритмаПодписания.XPathПодписываемыйТег;
	XPathSignedInfo         = ДанныеАлгоритмаПодписания.XPathSignedInfo;
	OIDАлгоритмаХеширования = ДанныеАлгоритмаПодписания.OIDАлгоритмаХеширования;
	ИмяАлгоритмаПодписи     = ДанныеАлгоритмаПодписания.ИмяАлгоритмаПодписи;
	
	Пароль = МенеджерКриптографии.ПарольДоступаКЗакрытомуКлючу;
	
	ОбъектКомпоненты = ОбъектВнешнейКомпонентыXMLDSig();
	
	ТипКриптопровайдера = ТипКриптопровайдера(МенеджерКриптографии);
	
	КонвертSOAP = СтрЗаменить(
		КонвертSOAP,
		"%BinarySecurityToken%",
		ЭлектроннаяПодписьСлужебныйКлиентСервер.СертификатКриптографииBase64(СертификатКриптографии.Выгрузить()));
	
	ПроверитьАлгоритмПодписи(ОбъектКомпоненты,
		ЭлектроннаяПодписьСлужебныйКлиентСервер.СертификатКриптографииBase64(СертификатКриптографии.Выгрузить()),
		ДанныеАлгоритмаПодписания);
	
	DigestValue = Hash(
		ОбъектКомпоненты,
		C14N(ОбъектКомпоненты, КонвертSOAP, XPathПодписываемыйТег),
		OIDАлгоритмаХеширования,
		ТипКриптопровайдера);
	
	КонвертSOAP = СтрЗаменить(КонвертSOAP, "%DigestValue%", DigestValue);
	
	SignatureValue = Sign(
		ОбъектКомпоненты,
		C14N(ОбъектКомпоненты, КонвертSOAP, XPathSignedInfo),
		СертификатКриптографии,
		Пароль);
	
	КонвертSOAP = СтрЗаменить(КонвертSOAP, "%SignatureValue%", SignatureValue);
	
	Возврат КонвертSOAP;
	
КонецФункции

// В параметре возвращается сертификат, с помощью которого была произведена подпись (если сертификат включен в данные подписи).
// Если проверка подписи завершилась неудачно, генерируется исключительная ситуация.
Функция ПроверитьПодпись(Знач КонвертSOAP, ДанныеАлгоритмаПодписания, МенеджерКриптографии) Экспорт
	
	XPathПодписываемыйТег   = ДанныеАлгоритмаПодписания.XPathПодписываемыйТег;
	XPathSignedInfo         = ДанныеАлгоритмаПодписания.XPathSignedInfo;
	OIDАлгоритмаХеширования = ДанныеАлгоритмаПодписания.OIDАлгоритмаХеширования;
	ИмяАлгоритмаПодписи     = ДанныеАлгоритмаПодписания.ИмяАлгоритмаПодписи;
	
	ОбъектКомпоненты = ОбъектВнешнейКомпонентыXMLDSig();
	
	ТипКриптопровайдера = ТипКриптопровайдера(МенеджерКриптографии);
	
	СертификатКриптографииBase64 = ЭлектроннаяПодписьСлужебныйКлиентСервер.НайтиВXML(КонвертSOAP, "wsse:BinarySecurityToken");
	
	ПроверитьАлгоритмПодписи(ОбъектКомпоненты, СертификатКриптографииBase64, ДанныеАлгоритмаПодписания);
	
	ПодписьВерна = VerifySign(
		ОбъектКомпоненты,
		C14N(ОбъектКомпоненты, КонвертSOAP, XPathSignedInfo),
		ЭлектроннаяПодписьСлужебныйКлиентСервер.НайтиВXML(КонвертSOAP, "SignatureValue"),
		СертификатКриптографииBase64,
		ТипКриптопровайдера);
	
	DigestValue = Hash(
		ОбъектКомпоненты,
		C14N(ОбъектКомпоненты, КонвертSOAP, XPathПодписываемыйТег),
		OIDАлгоритмаХеширования,
		ТипКриптопровайдера);
	
	ХешСовпадает = Ложь;
	Если DigestValue = ЭлектроннаяПодписьСлужебныйКлиентСервер.НайтиВXML(КонвертSOAP, "DigestValue") Тогда
		ХешСовпадает = Истина;
	КонецЕсли;
	
	Если ХешСовпадает И ПодписьВерна Тогда
		
		ДвоичныеДанные = Base64Значение(СертификатКриптографииBase64);
		
		ДатаПодписания = ЭлектроннаяПодпись.ДатаПодписания(ДвоичныеДанные);
		Если Не ЗначениеЗаполнено(ДатаПодписания) Тогда
			ДатаПодписания = Неопределено;
		КонецЕсли;
		
		ВозвращаемоеЗначение = Новый Структура;
		ВозвращаемоеЗначение.Вставить("Сертификат", Новый СертификатКриптографии(ДвоичныеДанные));
		ВозвращаемоеЗначение.Вставить("ДатаПодписания", ДатаПодписания);

		Возврат ВозвращаемоеЗначение;
		
	Иначе
		
		Если ПодписьВерна Тогда
			ВызватьИсключение НСтр("ru = 'Подпись не верна (SignatureValue корректно, отличается DigestValue).'")
		Иначе
			ВызватьИсключение НСтр("ru = 'Подпись не верна (SignatureValue не корректно.'");
		КонецЕсли;
		
	КонецЕсли;
	
КонецФункции


Функция ПодключитьВнешнююКомпонентуXMLDSig()
	
	ВнешняяКомпонента = Неопределено;
	
	ИмяКомпоненты = "Справочник.СертификатыКлючейЭлектроннойПодписиИШифрования.Макет.КомпонентаXMLDSig";
	ПодключениеВыполнено = ПодключитьВнешнююКомпоненту(ИмяКомпоненты, "ОбъектXMLDSig", ТипВнешнейКомпоненты.Native);
	
	// Создадим объект внешней компоненты.
	Если ПодключениеВыполнено Тогда
		
		Попытка
			ВнешняяКомпонента = Новый("Addin.ОбъектXMLDSig.XMLDSignAddIn");
		Исключение
			ВнешняяКомпонента = Неопределено;
		КонецПопытки;
		
	КонецЕсли;
	
	Возврат ВнешняяКомпонента;
	
КонецФункции

Функция ОбъектВнешнейКомпонентыXMLDSig()
	
	ОбъектКомпоненты = ПодключитьВнешнююКомпонентуXMLDSig();
	
	Если ОбъектКомпоненты = Неопределено Тогда
		ВызватьИсключение НСтр("ru='Не удалось подключить внешнюю компоненту XMLDSig.'");
	КонецЕсли;
	
	Возврат ОбъектКомпоненты;
	
КонецФункции

Функция ТипКриптопровайдера(МенеджерКриптографии)
	
	ИнформацияМодуляКриптографии = МенеджерКриптографии.ПолучитьИнформациюМодуляКриптографии();
	
	ИмяКриптопровайдера = ИнформацияМодуляКриптографии.Имя;
	ТипКриптопровайдера = ЭлектроннаяПодписьСлужебныйПовтИсп.ТипыПрограммЭлектроннойПодписи()[ИмяКриптопровайдера];
	
	Если ТипКриптопровайдера = Неопределено Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Не удалось определить тип криптопровайдера %1'"), ИмяКриптопровайдера);
	КонецЕсли;
	
	Возврат ТипКриптопровайдера;
	
КонецФункции

Функция GetSignOIDFromCert(ОбъектКомпоненты, СертификатКриптографииBase64)
	
	Попытка
		OIDАлгоритмаПодписи = ОбъектКомпоненты.GetSignOIDFromCert(СертификатКриптографииBase64);
	Исключение
		ВызватьИсключение НСтр("ru = 'Ошибка вызова метода GetSignOIDFromCert компоненты XMLDSig.'") + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Если OIDАлгоритмаПодписи = Неопределено Тогда
		ВызватьИсключение НСтр("ru = 'Ошибка вызова метода GetSignOIDFromCert компоненты XMLDSig.'") + Символы.ПС + ОбъектКомпоненты.GetLastError();
	КонецЕсли;
	
	Возврат OIDАлгоритмаПодписи;
	
КонецФункции

Функция C14N(ОбъектКомпоненты, КонвертSOAP, XPath)
	
	Попытка
		КаноникализированныйТекстXML = ОбъектКомпоненты.C14N(
			КонвертSOAP,
			XPath);
	Исключение
		ВызватьИсключение НСтр("ru = 'Ошибка вызова метода C14N компоненты XMLDSig.'") + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Если КаноникализированныйТекстXML = Неопределено Тогда
		ВызватьИсключение НСтр("ru = 'Ошибка вызова метода C14N компоненты XMLDSig.'") + Символы.ПС + ОбъектКомпоненты.GetLastError();
	КонецЕсли;
	
	Возврат КаноникализированныйТекстXML;
	
КонецФункции

Функция Hash(ОбъектКомпоненты, КаноникализированныйТекстXML, OIDАлгоритмаХеширования, ТипКриптопровайдера)
	
	Попытка
		DigestValue = ОбъектКомпоненты.Hash(
			КаноникализированныйТекстXML,
			OIDАлгоритмаХеширования,
			ТипКриптопровайдера);
	Исключение
		ВызватьИсключение НСтр("ru = 'Ошибка вызова метода Hash компоненты XMLDSig.'") + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Если DigestValue = Неопределено Тогда
		ВызватьИсключение НСтр("ru = 'Ошибка вызова метода Hash компоненты XMLDSig.'") + Символы.ПС + ОбъектКомпоненты.GetLastError();
	КонецЕсли;
	
	Возврат DigestValue;
	
КонецФункции

Функция Sign(ОбъектКомпоненты, КаноникализированныйТекстXMLSignedInfo, СертификатКриптографии, ПарольДоступаКЗакрытомуКлючу)
	
	Попытка
		SignatureValue = ОбъектКомпоненты.Sign(
			КаноникализированныйТекстXMLSignedInfo,
			ЭлектроннаяПодписьСлужебныйКлиентСервер.СертификатКриптографииBase64(СертификатКриптографии.Выгрузить()),
			ПарольДоступаКЗакрытомуКлючу);
	Исключение
		ВызватьИсключение НСтр("ru = 'Ошибка вызова метода Sign компоненты XMLDSig.'") + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Если SignatureValue = Неопределено Тогда
		ВызватьИсключение НСтр("ru = 'Ошибка вызова метода Sign компоненты XMLDSig.'") + Символы.ПС + ОбъектКомпоненты.GetLastError();
	КонецЕсли;
	
	Возврат SignatureValue;
	
КонецФункции

Функция VerifySign(ОбъектКомпоненты, КаноникализированныйТекстXMLSignedInfo, SignatureValue, СертификатКриптографииBase64, ТипКриптопровайдера)
	
	Попытка
		ПодписьВерна = ОбъектКомпоненты.VerifySign(
			КаноникализированныйТекстXMLSignedInfo,
			SignatureValue,
			СертификатКриптографииBase64,
			ТипКриптопровайдера);
	Исключение
		ВызватьИсключение НСтр("ru = 'Ошибка вызова метода VerifySign компоненты XMLDSig.'") + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Если ПодписьВерна = Неопределено Тогда
		ВызватьИсключение НСтр("ru = 'Ошибка вызова метода VerifySign компоненты XMLDSig.'") + Символы.ПС + ОбъектКомпоненты.GetLastError();
	КонецЕсли;
	
	Возврат ПодписьВерна;
	
КонецФункции

Процедура ПроверитьАлгоритмПодписи(ОбъектКомпоненты, СертификатКриптографииBase64, ДанныеАлгоритмаПодписания)
	
	OIDАлгоритмаПодписи = GetSignOIDFromCert(ОбъектКомпоненты, СертификатКриптографииBase64);
	Если OIDАлгоритмаПодписи <> ДанныеАлгоритмаПодписания.OIDАлгоритмаПодписи Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Алгоритм подписи сертификата криптографии отличается от алгоритма %1.'"),
			ДанныеАлгоритмаПодписания.ИмяАлгоритмаПодписи);
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Вспомогательные процедуры и функции.


// Для процедуры обновления ПеренестиНастройкиМенеджераКриптографии.
Процедура ОчиститьКонстанту(Константа)
	
	Если Не ЗначениеЗаполнено(Константа.Получить()) Тогда
		Возврат;
	КонецЕсли;
	
	МенеджерЗначения = Константа.СоздатьМенеджерЗначения();
	МенеджерЗначения.Значение = Неопределено;
	ОбновлениеИнформационнойБазы.ЗаписатьДанные(МенеджерЗначения);
	
КонецПроцедуры

// Для процедуры обновления ПеренестиНастройкиМенеджераКриптографии.
Процедура ОбработатьПутиНаСерверахLinux(Программа)
	
	// Обработка серверных путей
	НаборЗаписей = РегистрыСведений.ПутиКПрограммамЭлектроннойПодписиИШифрованияНаСерверахLinux.СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.Программа.Установить(Справочники.ПрограммыЭлектроннойПодписиИШифрования.ПустаяСсылка());
	НаборЗаписей.Прочитать();
	
	Если НаборЗаписей.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Программа) Тогда
		НаборЗаписейПрограммы = РегистрыСведений.ПутиКПрограммамЭлектроннойПодписиИШифрованияНаСерверахLinux.СоздатьНаборЗаписей();
		НаборЗаписейПрограммы.Отбор.Программа.Установить(Программа);
		НаборЗаписейПрограммы.Прочитать();
		Таблица = НаборЗаписейПрограммы.Выгрузить(, "ИмяКомпьютера, ПутьКПрограмме");
		Отбор = Новый Структура("ИмяКомпьютера, ПутьКПрограмме");
		
		Для каждого Запись Из НаборЗаписей Цикл
			ЗаполнитьЗначенияСвойств(Отбор, Запись);
			Строки = Таблица.НайтиСтроки(Отбор);
			Если Строки.Количество() = 0 Тогда
				НоваяЗапись = НаборЗаписейПрограммы.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяЗапись, Запись);
				НоваяЗапись.Программа = Программа;
			КонецЕсли;
		КонецЦикла;
		Если НаборЗаписейПрограммы.Модифицированность() Тогда
			ОбновлениеИнформационнойБазы.ЗаписатьДанные(НаборЗаписейПрограммы);
		КонецЕсли;
	КонецЕсли;
	
	НаборЗаписей.Очистить();
	ОбновлениеИнформационнойБазы.ЗаписатьДанные(НаборЗаписей);
	
КонецПроцедуры

// Для процедуры обновления ПеренестиНастройкиМенеджераКриптографии.
Процедура ОбработатьПутиНаКлиентахLinux(Программа)
	
	// Обработка клиентских путей
	ПользователиИБ = ПользователиИнформационнойБазы.ПолучитьПользователей();
	КлючПодсистемы = "ЭЦП"; // Не заменять на "ЭП". Используется для обратной совместимости.
	СтарыйКлючНастроек = "ПутьМодуляКриптографии";
	НовыйКлючНастроек  = "ПутиКПрограммамЭлектроннойПодписиИШифрования";
	Для каждого ПользовательИБ Из ПользователиИБ Цикл
		Путь = ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить(КлючПодсистемы, СтарыйКлючНастроек,,,
			ПользовательИБ.Имя);
		Если Не ЗначениеЗаполнено(Путь) Тогда
			Продолжить;
		КонецЕсли;
		Настройки = Новый Соответствие;
		Настройки.Вставить(Программа, Путь);
		ОбщегоНазначения.ХранилищеОбщихНастроекСохранить(КлючПодсистемы, НовыйКлючНастроек, Настройки,,
			ПользовательИБ.Имя)
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры обновления ПеренестиНастройкиМенеджераКриптографии.
Функция СтараяПрограмма()
	
	ИмяПрограммы = СокрЛП(Константы.УдалитьПровайдерЭП.Получить());
	ТипПрограммы = Константы.УдалитьТипПровайдераЭП.Получить();
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИСТИНА КАК ЗначениеИстина
	|ИЗ
	|	РегистрСведений.ПутиКПрограммамЭлектроннойПодписиИШифрованияНаСерверахLinux КАК Пути
	|ГДЕ
	|	Пути.Программа = ЗНАЧЕНИЕ(Справочник.СертификатыКлючейЭлектроннойПодписиИШифрования.ПустаяСсылка)";
	
	Если Не ЗначениеЗаполнено(ИмяПрограммы)
	   И Не ЗначениеЗаполнено(ТипПрограммы)
	   И Запрос.Выполнить().Пустой() Тогда
	
		Возврат Неопределено;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ИмяПрограммы", ИмяПрограммы);
	Запрос.УстановитьПараметр("ТипПрограммы", ТипПрограммы);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Программы.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.ПрограммыЭлектроннойПодписиИШифрования КАК Программы
	|ГДЕ
	|	Программы.ИмяПрограммы = &ИмяПрограммы
	|	И Программы.ТипПрограммы = &ТипПрограммы";
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		ПрограммаОбъект = Справочники.ПрограммыЭлектроннойПодписиИШифрования.СоздатьЭлемент();
		ПрограммаОбъект.Наименование = ИмяПрограммы;
		ПрограммаОбъект.ИмяПрограммы = ИмяПрограммы;
		ПрограммаОбъект.ТипПрограммы = ТипПрограммы;
	Иначе
		ПрограммаОбъект = РезультатЗапроса.Выгрузить()[0].Ссылка.ПолучитьОбъект();
	КонецЕсли;
	
	ПрограммаОбъект.АлгоритмПодписи     = Константы.УдалитьАлгоритмПодписи.Получить();
	ПрограммаОбъект.АлгоритмХеширования = Константы.УдалитьАлгоритмХеширования.Получить();
	ПрограммаОбъект.АлгоритмШифрования  = Константы.УдалитьАлгоритмШифрования.Получить();
	
	Возврат ПрограммаОбъект;
	
КонецФункции

// Для процедуры ОбновитьСписокСертификатов.
Процедура ОбработатьДобавленныеСертификаты(ТаблицаСвойствСертификатов, КромеУжеДобавленных)
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Отпечатки", ТаблицаСвойствСертификатов.Скопировать(, "Отпечаток"));
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Отпечатки.Отпечаток
	|ПОМЕСТИТЬ Отпечатки
	|ИЗ
	|	&Отпечатки КАК Отпечатки
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	Сертификаты.Отпечаток,
	|	Сертификаты.Наименование КАК Представление,
	|	ВЫБОР
	|		КОГДА Сертификаты.СостояниеЗаявления = ЗНАЧЕНИЕ(Перечисление.СостоянияЗаявленияНаВыпускСертификата.ПустаяСсылка)
	|			ТОГДА ЛОЖЬ
	|		КОГДА Сертификаты.СостояниеЗаявления = ЗНАЧЕНИЕ(Перечисление.СостоянияЗаявленияНаВыпускСертификата.Исполнено)
	|			ТОГДА ЛОЖЬ
	|		ИНАЧЕ ИСТИНА
	|	КОНЕЦ КАК ЭтоЗаявление
	|ИЗ
	|	Справочник.СертификатыКлючейЭлектроннойПодписиИШифрования КАК Сертификаты
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Отпечатки КАК Отпечатки
	|		ПО Сертификаты.Отпечаток = Отпечатки.Отпечаток";
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		Строка = ТаблицаСвойствСертификатов.Найти(Выборка.Отпечаток, "Отпечаток");
		Если КромеУжеДобавленных Тогда
			Если Строка <> Неопределено Тогда // Защита от ошибки в данных (дубли сертификатов).
				ТаблицаСвойствСертификатов.Удалить(Строка);
			КонецЕсли;
		Иначе
			Строка.Представление = Выборка.Представление;
			Строка.ЭтоЗаявление  = Выборка.ЭтоЗаявление;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ОбновитьСписокСертификатов.
Процедура ОбновитьЗначение(СтароеЗначение, НовоеЗначение, ПропускатьНеопределенныеЗначения = Ложь)
	
	Если НовоеЗначение = Неопределено И ПропускатьНеопределенныеЗначения Тогда
		Возврат;
	КонецЕсли;
	
	Если СтароеЗначение <> НовоеЗначение Тогда
		СтароеЗначение = НовоеЗначение;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры СохраненныеСвойстваСертификата.
Процедура ЗаполнитьРеквизит(СохраненныеСвойства, ПараметрыРеквизитов, ИмяРеквизита)
	
	Если ПараметрыРеквизитов.Свойство(ИмяРеквизита)
	   И ПараметрыРеквизитов[ИмяРеквизита].ЗначениеЗаполнения <> Неопределено Тогда
		
		СохраненныеСвойства[ИмяРеквизита] = ПараметрыРеквизитов[ИмяРеквизита].ЗначениеЗаполнения;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры НастроитьФормуПодписанияШифрованияРасшифровки.
Процедура ЗаполнитьОтборОтпечатков(Форма)
	
	Параметры = Форма.Параметры;
	
	Отбор = Новый Соответствие;
	
	Если ТипЗнч(Параметры.СертификатыШифрования) = Тип("Массив") Тогда
		Описания = Новый Соответствие;
		Отпечатки = Новый Соответствие;
		ПредставленияОтпечатков = Новый Соответствие;
		
		Для каждого Описание Из Параметры.СертификатыШифрования Цикл
			Если Описания[Описание] <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			Описания.Вставить(Описание, Истина);
			Сертификаты = СертификатыШифрованияИзОписания(Описание);
			
			Для каждого Свойства Из Сертификаты Цикл
				Значение = Отпечатки[Свойства.Отпечаток];
				Значение = ?(Значение = Неопределено, 1, Значение + 1);
				Отпечатки.Вставить(Свойства.Отпечаток, Значение);
				ПредставленияОтпечатков.Вставить(Свойства.Отпечаток, Свойства.Представление);
			КонецЦикла;
		КонецЦикла;
		КоличествоЭлементовДанных = Параметры.СертификатыШифрования.Количество();
		Для каждого КлючИЗначение Из Отпечатки Цикл
			Если КлючИЗначение.Значение = КоличествоЭлементовДанных Тогда
				Отбор.Вставить(КлючИЗначение.Ключ, ПредставленияОтпечатков[КлючИЗначение.Ключ]);
			КонецЕсли;
		КонецЦикла;
		
	ИначеЕсли Параметры.СертификатыШифрования <> Неопределено Тогда
		
		Сертификаты = СертификатыШифрованияИзОписания(Параметры.СертификатыШифрования);
		Для каждого Свойства Из Сертификаты Цикл
			Отбор.Вставить(Свойства.Отпечаток, Свойства.Представление);
		КонецЦикла;
	КонецЕсли;
	
	Форма.ОтборОтпечатков = ПоместитьВоВременноеХранилище(Отбор, Форма.УникальныйИдентификатор);
	
КонецПроцедуры

// Для процедуры ЗаполнитьОтборОтпечатков.
Функция СертификатыШифрованияИзОписания(Описание)
	
	Если ТипЗнч(Описание) = Тип("Строка") Тогда
		Возврат ПолучитьИзВременногоХранилища(Описание);
	КонецЕсли;
	
	Сертификаты = Новый Массив;
	
	Выборка = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Описание, "СертификатыШифрования").Выбрать();
	Пока Выборка.Следующий() Цикл
		СвойстваСертификата = Новый Структура("Отпечаток, Представление, Сертификат");
		ЗаполнитьЗначенияСвойств(СвойстваСертификата, Выборка);
		СвойстваСертификата.Сертификат = СвойстваСертификата.Сертификат.Получить();
		Сертификаты.Добавить(СвойстваСертификата);
	КонецЦикла;
	
	Возврат Сертификаты;
	
КонецФункции

// Для процедур НастроитьФормуПодписанияШифрованияРасшифровки, СертификатПриИзмененииНаСервере.

Процедура ЗаполнитьСуществующиеСертификатыПользователя(СписокВыбора, ОтпечаткиСертификатовНаКлиенте,
			ОтборСертификатов, ОтборОтпечатков = Неопределено)
	
	СписокВыбора.Очистить();
	
	Если ЭлектроннаяПодпись.ОбщиеНастройки().СоздаватьЭлектронныеПодписиНаСервере Тогда
		
		МенеджерКриптографии = МенеджерКриптографии("ПолучениеСертификатов", Ложь);
		
		Если МенеджерКриптографии <> Неопределено Тогда
			ТипХранилища = ТипХранилищаСертификатовКриптографии.ПерсональныеСертификаты;
			МассивСертификатов = МенеджерКриптографии.ПолучитьХранилищеСертификатов(ТипХранилища).ПолучитьВсе();
			
			ЭлектроннаяПодписьСлужебныйКлиентСервер.ДобавитьОтпечаткиСертификатов(
				ОтпечаткиСертификатовНаКлиенте, МассивСертификатов);
		КонецЕсли;
	КонецЕсли;
	
	Если ОтборСертификатов.Количество() > 0 Тогда
		Для каждого ЭлементСписка Из ОтборСертификатов Цикл
			Свойства = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(
				ЭлементСписка.Значение, "Ссылка, Наименование, Отпечаток");
			
			Если ОтпечаткиСертификатовНаКлиенте.Найти(Свойства.Отпечаток) <> Неопределено Тогда
				СписокВыбора.Добавить(Свойства.Ссылка, Свойства.Наименование);
			КонецЕсли;
		КонецЦикла;
		Возврат;
	КонецЕсли;
	
	Если ОтборОтпечатков <> Неопределено Тогда
		Отбор = ПолучитьИзВременногоХранилища(ОтборОтпечатков);
		Отпечатки = Новый Массив;
		Для каждого Отпечаток Из ОтпечаткиСертификатовНаКлиенте Цикл
			Если Отбор[Отпечаток] = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			СписокВыбора.Добавить(Отпечаток, Отбор[Отпечаток]);
		КонецЦикла;
		Запрос = Новый Запрос;
		Запрос.Параметры.Вставить("Отпечатки", СписокВыбора.ВыгрузитьЗначения());
		Запрос.Текст =
		"ВЫБРАТЬ
		|	Сертификаты.Ссылка КАК Ссылка,
		|	Сертификаты.Наименование КАК Наименование,
		|	Сертификаты.Отпечаток
		|ИЗ
		|	Справочник.СертификатыКлючейЭлектроннойПодписиИШифрования КАК Сертификаты
		|ГДЕ
		|	Сертификаты.Отпечаток В(&Отпечатки)";
		Выборка = Запрос.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			ЭлементСписка = СписокВыбора.НайтиПоЗначению(Выборка.Отпечаток);
			Если ЭлементСписка <> Неопределено Тогда
				ЭлементСписка.Значение = Выборка.Ссылка;
				ЭлементСписка.Представление = Выборка.Наименование;
			КонецЕсли;
		КонецЦикла;
		СписокВыбора.СортироватьПоПредставлению();
		Возврат;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Пользователь", ПользователиКлиентСервер.ТекущийПользователь());
	Запрос.Параметры.Вставить("Отпечатки", ОтпечаткиСертификатовНаКлиенте);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Сертификаты.Ссылка КАК Ссылка,
	|	Сертификаты.Наименование КАК Наименование
	|ИЗ
	|	Справочник.СертификатыКлючейЭлектроннойПодписиИШифрования КАК Сертификаты
	|ГДЕ
	|	Сертификаты.Программа <> ЗНАЧЕНИЕ(Справочник.ПрограммыЭлектроннойПодписиИШифрования.ПустаяСсылка)
	|	И Сертификаты.Пользователь = &Пользователь
	|	И Сертификаты.Отозван = ЛОЖЬ
	|	И Сертификаты.Отпечаток В(&Отпечатки)
	|
	|УПОРЯДОЧИТЬ ПО
	|	Наименование";
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		СписокВыбора.Добавить(Выборка.Ссылка, Выборка.Наименование);
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаполнитьДополнительныеСвойстваСертификата(Форма)
	
	Если Не ЗначениеЗаполнено(Форма.Сертификат) Тогда
		Возврат;
	КонецЕсли;
	
	Элементы = Форма.Элементы;
	
	ЗначенияРеквизитов = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Форма.Сертификат,
		"УсиленнаяЗащитаЗакрытогоКлюча, Отпечаток, Программа,
		|ДействителенДо, ПользовательОповещенОСрокеДействия, ДанныеСертификата");
	
	Попытка
		ДвоичныеДанныеСертификата = ЗначенияРеквизитов.ДанныеСертификата.Получить();
		СертификатКриптографии = Новый СертификатКриптографии(ДвоичныеДанныеСертификата);
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Сертификат = Форма.Сертификат;
		Форма.Сертификат = Неопределено;
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'При получении данных сертификата ""%1""
			           |из информационной базы возникла ошибка:
			           |%2'"),
			Сертификат,
			КраткоеПредставлениеОшибки(ИнформацияОбОшибке));
	КонецПопытки;
	
	Форма.СертификатАдрес = ПоместитьВоВременноеХранилище(ДвоичныеДанныеСертификата, Форма.УникальныйИдентификатор);
	
	Форма.СертификатОтпечаток      = ЗначенияРеквизитов.Отпечаток;
	Форма.СертификатПрограмма      = ЗначенияРеквизитов.Программа;
	Форма.ВыполнятьВМоделиСервиса  = ЗначенияРеквизитов.Программа.ЭтоПрограммаОблачногоСервиса;
	Форма.СертификатДействителенДо = ЗначенияРеквизитов.ДействителенДо;
	Форма.СертификатУсиленнаяЗащитаЗакрытогоКлюча = ЗначенияРеквизитов.УсиленнаяЗащитаЗакрытогоКлюча;
	
	Форма.ОповеститьОбОкончанииСрокаДействия =
		Не ЗначенияРеквизитов.ПользовательОповещенОСрокеДействия
		И ДобавитьМесяц(ТекущаяДатаСеанса(), 1) > Форма.СертификатДействителенДо;
	
	Форма.СертификатНаСервереОписаниеОшибки = Новый Структура;
	
	Если Не ЭлектроннаяПодписьКлиентСервер.ОбщиеНастройки().СоздаватьЭлектронныеПодписиНаСервере Тогда
		Возврат;
	КонецЕсли;
	
	ПолучитьСертификатПоОтпечатку(Форма.СертификатОтпечаток,
		Истина, Ложь, Форма.СертификатПрограмма, Форма.СертификатНаСервереОписаниеОшибки);
	
КонецПроцедуры

// Для функции МенеджерКриптографии.
Функция НовыйМенеджерКриптографии(Программа, Ошибки, ИмяКомпьютера)
	
	ОписанияПрограмм = ЭлектроннаяПодписьСлужебныйКлиентСервер.МенеджерКриптографииОписанияПрограмм(
		Программа, Ошибки);
	
	Если ОписанияПрограмм = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ЭтоLinux = ОбщегоНазначения.ЭтоLinuxСервер();
	
	Если ЭтоLinux Тогда
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("ИмяКомпьютера", ИмяКомпьютера);
		Запрос.Текст =
		"ВЫБРАТЬ
		|	ПутиКПрограмме.Программа,
		|	ПутиКПрограмме.ПутьКПрограмме
		|ИЗ
		|	РегистрСведений.ПутиКПрограммамЭлектроннойПодписиИШифрованияНаСерверахLinux КАК ПутиКПрограмме
		|ГДЕ
		|	ПутиКПрограмме.ИмяКомпьютера = &ИмяКомпьютера";
		
		ПутиКПрограммамНаСерверахLinux = Новый Соответствие;
		Выборка = Запрос.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			ПутиКПрограммамНаСерверахLinux.Вставить(Выборка.Программа, Выборка.ПутьКПрограмме);
		КонецЦикла;
	Иначе
		ПутиКПрограммамНаСерверахLinux = Неопределено;
	КонецЕсли;
	
	Менеджер = Неопределено;
	Для каждого ОписаниеПрограммы Из ОписанияПрограмм Цикл
		
		СвойстваПрограммы = ЭлектроннаяПодписьСлужебныйКлиентСервер.МенеджерКриптографииСвойстваПрограммы(
			ОписаниеПрограммы, ЭтоLinux, Ошибки, Истина, ПутиКПрограммамНаСерверахLinux);
		
		Если СвойстваПрограммы = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Попытка
			ИнформацияМодуля = СредстваКриптографии.ПолучитьИнформациюМодуляКриптографии(
				СвойстваПрограммы.ИмяПрограммы,
				СвойстваПрограммы.ПутьКПрограмме,
				СвойстваПрограммы.ТипПрограммы);
		Исключение
			ЭлектроннаяПодписьСлужебныйКлиентСервер.МенеджерКриптографииДобавитьОшибку(Ошибки,
				ОписаниеПрограммы.Ссылка, КраткоеПредставлениеОшибки(ИнформацияОбОшибке()),
				Истина, Истина, Истина);
			Продолжить;
		КонецПопытки;
		
		Если ИнформацияМодуля = Неопределено Тогда
			ЭлектроннаяПодписьСлужебныйКлиентСервер.МенеджерКриптографииПрограммаНеНайдена(
				ОписаниеПрограммы, Ошибки, Истина);
			
			Менеджер = Неопределено;
			Продолжить;
		КонецЕсли;
		
		Если Не ЭтоLinux Тогда
			ИмяПрограммыПолученное = ИнформацияМодуля.Имя;
			
			ИмяПрограммыСовпадает = ЭлектроннаяПодписьСлужебныйКлиентСервер.МенеджерКриптографииИмяПрограммыСовпадает(
				ОписаниеПрограммы, ИмяПрограммыПолученное, Ошибки, Истина);
			
			Если Не ИмяПрограммыСовпадает Тогда
				Менеджер = Неопределено;
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		Попытка
			Менеджер = Новый МенеджерКриптографии(
				СвойстваПрограммы.ИмяПрограммы,
				СвойстваПрограммы.ПутьКПрограмме,
				СвойстваПрограммы.ТипПрограммы);
		Исключение
			ЭлектроннаяПодписьСлужебныйКлиентСервер.МенеджерКриптографииДобавитьОшибку(Ошибки,
				ОписаниеПрограммы.Ссылка, КраткоеПредставлениеОшибки(ИнформацияОбОшибке()),
				Истина, Истина, Истина);
			Продолжить;
		КонецПопытки;
		
		АлгоритмыУстановлены = ЭлектроннаяПодписьСлужебныйКлиентСервер.МенеджерКриптографииАлгоритмыУстановлены(
			ОписаниеПрограммы, Менеджер, Ошибки);
		
		Если Не АлгоритмыУстановлены Тогда
			Продолжить;
		КонецЕсли;
		
		Прервать; // Требуемый менеджер криптографии получен.
	КонецЦикла;
	
	Возврат Менеджер;
	
КонецФункции

Функция ИспользоватьЭлектроннуюПодписьВМоделиСервиса() Экспорт
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ТехнологияСервиса.РаботаВМоделиСервиса.ЭлектроннаяПодписьВМоделиСервиса") Тогда
		МодульЭлектроннаяПодписьВМоделиСервисаКлиентСервер = ОбщегоНазначения.ОбщийМодуль("ЭлектроннаяПодписьВМоделиСервисаКлиентСервер");
		Возврат МодульЭлектроннаяПодписьВМоделиСервисаКлиентСервер.ИспользованиеВозможно();
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции


#КонецОбласти
