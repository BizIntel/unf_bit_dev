////////////////////////////////////////////////////////////////////////////////
// ОчередьЗаданий: Работа с очередью заданий.
//
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Возвращает следующую дата выполнения расписания.
//
// Параметры:
//  Расписание - РасписаниеРегламентногоЗадания - расписание по которому
//   будет рассчитываться дата.
//  ДатаДляПроверки - Дата (ДатаВремя) - минимальная дата на которую может
//   быть запланировано выполнение.
//  ДатаНачалаПоследнегоЗапуска - Дата (ДатаВремя) - Дата начала последнего 
//   запуска задания. Если дата задана, то используется для проверки таких 
//   условий как ПериодПовтораДней, ПериодНедель, ПериодПовтораВТечениеДня. 
//   Если дата не задана, то считается, что задание не выполнялось ни разу 
//   и проверка этих условий не производится. 
//  ДатаЗавершенияПоследнегоЗапуска - Дата (ДатаВремя) - Дата завершения 
//   последнего запуска задания. Если дата задана, то используется для 
//   проверки условия ПаузаПовтора. Если дата не задана, то считается, что 
//   задание ни разу не завершалось, и проверка этого условия не производится. 
//  МаксимальныйГоризонтПланирования - Число - Максимальное количество секунд
//   относительно ДатаДляПроверки на которое может быть выполнено планирование.
//   Увеличение значения может привести к замедлению расчета на сложных
//   расписаниях.
//
Функция СледующаяДатаВыполненияРасписания(Знач Расписание, Знач ДатаДляПроверки, 
	Знач ДатаНачалаПоследнегоЗапуска = Неопределено, Знач ДатаЗавершенияПоследнегоЗапуска = Неопределено, 
	Знач МаксимальныйГоризонтПланирования = Неопределено) Экспорт
	
	Если МаксимальныйГоризонтПланирования = Неопределено Тогда
		МаксимальныйГоризонтПланирования = 366 * 86400 * 10;
	КонецЕсли;
	
	ИсходнаяДатаДляПроверки = ДатаДляПроверки;
	ВремяНачалаПоследнегоЗапуска = '00010101' + (ДатаНачалаПоследнегоЗапуска - НачалоДня(ДатаНачалаПоследнегоЗапуска));
	
	// Границы по датам
	Если ЗначениеЗаполнено(Расписание.ДатаКонца)
		И ДатаДляПроверки > Расписание.ДатаКонца Тогда
		
		// Интервал выполнения по дням закончился.
		Возврат '00010101';
	КонецЕсли;
		
	Если ДатаДляПроверки < Расписание.ДатаНачала Тогда
		ДатаДляПроверки = Расписание.ДатаНачала;
	КонецЕсли;
	
	МожноМенятьДень = Истина;
	
	// Учет периодичности
	Если ЗначениеЗаполнено(ДатаНачалаПоследнегоЗапуска) Тогда
		
		// Период недель
		Если Расписание.ПериодНедель > 1
			И (НачалоНедели(ДатаДляПроверки) - НачалоНедели(ДатаНачалаПоследнегоЗапуска)) / (7 * 86400) < Расписание.ПериодНедель Тогда
		
			ДатаДляПроверки = НачалоНедели(ДатаНачалаПоследнегоЗапуска) + 7 * 86400 * Расписание.ПериодНедель;
		КонецЕсли;
		
		// Период дней
		Если Расписание.ПериодПовтораДней = 0 Тогда
			Если НачалоДня(ДатаДляПроверки) <> НачалоДня(ДатаНачалаПоследнегоЗапуска) Тогда
				// Повторения не установлено и задание уже выполнялось.
				Возврат '00010101';
			КонецЕсли;
			
			МожноМенятьДень = Ложь;
		КонецЕсли;
		
		Если Расписание.ПериодПовтораДней > 1
			И НачалоДня(ДатаДляПроверки) - НачалоДня(ДатаНачалаПоследнегоЗапуска) < (Расписание.ПериодПовтораДней - 1)* 86400 Тогда
			
			ДатаДляПроверки = НачалоДня(ДатаНачалаПоследнегоЗапуска) + Расписание.ПериодПовтораДней * 86400;
		КонецЕсли;
		
		// Если задание повторяется раз в день (но не чаще) то сдвигаем на следующий день после последнего запуска.
		Если Расписание.ПериодПовтораДней = 1 И Расписание.ПериодПовтораВТечениеДня = 0 Тогда
			ДатаДляПроверки = Макс(ДатаДляПроверки, НачалоДня(ДатаНачалаПоследнегоЗапуска+86400));
		КонецЕсли;

	КонецЕсли;
	
	// Учет допустимых интервалов запуска.
	ПоменятьМесяц = Ложь;
	ПоменятьДень = Ложь;
	Пока Истина Цикл
		
		Если ДатаДляПроверки - ИсходнаяДатаДляПроверки > МаксимальныйГоризонтПланирования Тогда
			// Отложить планирование
			Возврат '00010101';
		КонецЕсли;
		
		Если НЕ МожноМенятьДень
			И (ПоменятьДень ИЛИ ПоменятьМесяц) Тогда
			
			// Повторения не установлено и задание уже выполнялось.
			Возврат '00010101';
		КонецЕсли;
		
		// Месяцы
		Пока ПоменятьМесяц
			ИЛИ Расписание.Месяцы.Количество() > 0 
			И Расписание.Месяцы.Найти(Месяц(ДатаДляПроверки)) = Неопределено Цикл
			
			ПоменятьМесяц = Ложь;
			
			// Переход на следующий месяц
			ДатаДляПроверки = НачалоМесяца(ДобавитьМесяц(ДатаДляПроверки, 1));
		КонецЦикла;
		
		// День месяца
		ДнейВМесяце = День(КонецМесяца(ДатаДляПроверки));
		Если Расписание.ДеньВМесяце <> 0 Тогда
			
			ТекущийДень = День(ДатаДляПроверки);
			
			Если Расписание.ДеньВМесяце > 0 
				И (ДнейВМесяце < Расписание.ДеньВМесяце ИЛИ ТекущийДень > Расписание.ДеньВМесяце)
				ИЛИ Расписание.ДеньВМесяце < 0 
				И (ДнейВМесяце < -Расписание.ДеньВМесяце ИЛИ ТекущийДень > ДнейВМесяце - -Расписание.ДеньВМесяце) Тогда
				
				// В этом месяце нет такого числа или оно уже прошло.
				ПоменятьМесяц = Истина;
				Продолжить;
			КонецЕсли;
			
			Если Расписание.ДеньВМесяце > 0 Тогда
				ДатаДляПроверки = НачалоМесяца(ДатаДляПроверки) + (Расписание.ДеньВМесяце - 1) * 86400;
			КонецЕсли;
			
			Если Расписание.ДеньВМесяце < 0 Тогда
				ДатаДляПроверки = НачалоДня(КонецМесяца(ДатаДляПроверки)) - (-Расписание.ДеньВМесяце -1) * 86400;
			КонецЕсли;
		КонецЕсли;
		
		// День недели в месяце
		Если Расписание.ДеньНеделиВМесяце <> 0 Тогда
			Если Расписание.ДеньНеделиВМесяце > 0 Тогда
				ДеньНачалаНедели = (Расписание.ДеньНеделиВМесяце - 1) * 7 + 1;
			КонецЕсли;
			Если Расписание.ДеньНеделиВМесяце < 0 Тогда
				ДеньНачалаНедели = ДнейВМесяце - (-Расписание.ДеньНеделиВМесяце) * 7 + 1;
			КонецЕсли;
			
			ДеньКонцаНедели = Мин(ДеньНачалаНедели + 6, ДнейВМесяце);
			
			Если День(ДатаДляПроверки) > ДеньКонцаНедели 
				ИЛИ ДеньНачалаНедели > ДнейВМесяце Тогда
				// В этом месяце нужная неделя уже прошла (или ее не было).
				ПоменятьМесяц = Истина;
				Продолжить;
			КонецЕсли;
			
			Если День(ДатаДляПроверки) < ДеньНачалаНедели Тогда
				Если Расписание.ДеньВМесяце <> 0 Тогда
					
					// День зафиксирован и он не подходит.
					ПоменятьМесяц = Истина;
					Продолжить;
				КонецЕсли;
				ДатаДляПроверки = НачалоМесяца(ДатаДляПроверки) + (ДеньНачалаНедели - 1) * 86400;
			КонецЕсли;
		КонецЕсли;
		
		// День недели
		Пока ПоменятьДень
			ИЛИ Расписание.ДниНедели.Найти(ДеньНедели(ДатаДляПроверки)) = Неопределено
			И Расписание.ДниНедели.Количество() > 0 Цикл
			
			ПоменятьДень = Ложь;
			
			Если Расписание.ДеньВМесяце <> 0 Тогда
				// День зафиксирован и он не подходит.
				ПоменятьМесяц = Истина;
				Прервать;
			КонецЕсли;
			
			Если День(ДатаДляПроверки) = ДнейВМесяце Тогда
				// Месяц кончился
				ПоменятьМесяц = Истина;
				Прервать;
			КонецЕсли;
			
			Если Расписание.ДеньНеделиВМесяце <> 0
				И День(ДатаДляПроверки) = ДеньКонцаНедели Тогда
				
				// Нужная неделя кончилась
				ПоменятьМесяц = Истина;
				Прервать;
			КонецЕсли;
			
			ДатаДляПроверки = НачалоДня(ДатаДляПроверки) + 86400;
		КонецЦикла;
		Если ПоменятьМесяц Тогда
			Продолжить;
		КонецЕсли;
		
		// Учет времени
		ВремяДляПроверки = '00010101' + (ДатаДляПроверки - НачалоДня(ДатаДляПроверки));
		
		Если Расписание.ДетальныеРасписанияДня.Количество() = 0 Тогда
			ДетальныеРасписания = Новый Массив;
			ДетальныеРасписания.Добавить(Расписание);
		Иначе
			ДетальныеРасписания = Расписание.ДетальныеРасписанияДня;
		КонецЕсли;
		
		// Если у нас есть промежутки, с переходом через полночь, то разбиваем их на два промежутка.
		Индекс = 0;
		Пока Индекс < ДетальныеРасписания.Количество() Цикл
			
			РасписаниеДня = ДетальныеРасписания[Индекс];
			
			Если НЕ ЗначениеЗаполнено(РасписаниеДня.ВремяНачала) ИЛИ НЕ ЗначениеЗаполнено(РасписаниеДня.ВремяКонца) Тогда
				Индекс = Индекс + 1;
				Продолжить;
			КонецЕсли;
			
			Если РасписаниеДня.ВремяНачала > РасписаниеДня.ВремяКонца Тогда
				
				РасписаниеДняПерваяПоловина = Новый РасписаниеРегламентногоЗадания();
				ЗаполнитьЗначенияСвойств(РасписаниеДняПерваяПоловина,РасписаниеДня);
				РасписаниеДняПерваяПоловина.ВремяНачала = НачалоДня(РасписаниеДняПерваяПоловина.ВремяНачала);
				ДетальныеРасписания.Добавить(РасписаниеДняПерваяПоловина);
				
				РасписаниеДняВтораяПоловина = Новый РасписаниеРегламентногоЗадания();
				ЗаполнитьЗначенияСвойств(РасписаниеДняВтораяПоловина,РасписаниеДня);
				РасписаниеДняВтораяПоловина.ВремяКонца = КонецДня(РасписаниеДняВтораяПоловина.ВремяНачала);
				ДетальныеРасписания.Добавить(РасписаниеДняВтораяПоловина);
				
				ДетальныеРасписания.Удалить(Индекс);
				
			Иначе
				
				Индекс = Индекс + 1;
				
			КонецЕсли;
		
		КонецЦикла;
		
		Для Индекс = 0 По ДетальныеРасписания.ВГраница() Цикл
			РасписаниеДня = ДетальныеРасписания[Индекс];
			
			// Границы по времени
			Если ЗначениеЗаполнено(РасписаниеДня.ВремяНачала)
				И ВремяДляПроверки < РасписаниеДня.ВремяНачала Тогда
				
				ВремяДляПроверки = РасписаниеДня.ВремяНачала;
			КонецЕсли;
			
			Если ЗначениеЗаполнено(РасписаниеДня.ВремяКонца)
				И ВремяДляПроверки > РасписаниеДня.ВремяКонца Тогда
				
				Если Индекс < ДетальныеРасписания.ВГраница() Тогда
					// Есть еще расписания дня
					Продолжить;
				КонецЕсли;
				
				// В этом дне подходящее время уже прошло.
				ПоменятьДень = Истина;
				Прервать;
			КонецЕсли;
			
			// Период повтора в течении дня.
			Если ЗначениеЗаполнено(ДатаНачалаПоследнегоЗапуска) Тогда
				
				Если РасписаниеДня.ПериодПовтораВТечениеДня = 0
					И НачалоДня(ДатаДляПроверки) = НачалоДня(ДатаНачалаПоследнегоЗапуска)
					И (НЕ ЗначениеЗаполнено(РасписаниеДня.ВремяНачала) 
						ИЛИ ЗначениеЗаполнено(РасписаниеДня.ВремяНачала) И ВремяНачалаПоследнегоЗапуска >= РасписаниеДня.ВремяНачала)
					И (НЕ ЗначениеЗаполнено(РасписаниеДня.ВремяКонца) 
						ИЛИ ЗначениеЗаполнено(РасписаниеДня.ВремяКонца) И ВремяНачалаПоследнегоЗапуска <= РасписаниеДня.ВремяКонца) Тогда
					
					// В этом интервале (расписании дня) задание уже выполнялось и повторы не установлены.
					Если Индекс < ДетальныеРасписания.ВГраница() Тогда
						Продолжить;
					КонецЕсли;
					
					ПоменятьДень = Истина;
					Прервать;
				КонецЕсли;
				
				Если НачалоДня(ДатаДляПроверки) = НачалоДня(ДатаНачалаПоследнегоЗапуска)
					И ВремяДляПроверки - ВремяНачалаПоследнегоЗапуска < РасписаниеДня.ПериодПовтораВТечениеДня Тогда
					
					НовоеВремяДляПроверки = ВремяНачалаПоследнегоЗапуска + РасписаниеДня.ПериодПовтораВТечениеДня;
					
					Если ЗначениеЗаполнено(РасписаниеДня.ВремяКонца) И НовоеВремяДляПроверки > РасписаниеДня.ВремяКонца
						ИЛИ НачалоДня(НовоеВремяДляПроверки) <> НачалоДня(ВремяДляПроверки) Тогда
						
						// Время ушло за интервал
						Если Индекс < ДетальныеРасписания.ВГраница() Тогда
							Продолжить;
						КонецЕсли;
						
						ПоменятьДень = Истина;
						Прервать;
					КонецЕсли;
					
					ВремяДляПроверки = НовоеВремяДляПроверки;
					
				КонецЕсли;
				
			КонецЕсли;
			
			// Пауза
			Если ЗначениеЗаполнено(ДатаЗавершенияПоследнегоЗапуска) 
				И ЗначениеЗаполнено(РасписаниеДня.ПаузаПовтора) Тогда
				
				ВремяЗавершенияПоследнегоЗапуска = '00010101' + (ДатаЗавершенияПоследнегоЗапуска - НачалоДня(ДатаЗавершенияПоследнегоЗапуска));
				
				Если НачалоДня(ДатаДляПроверки) = НачалоДня(ДатаНачалаПоследнегоЗапуска)
					И ВремяДляПроверки - ВремяЗавершенияПоследнегоЗапуска < РасписаниеДня.ПаузаПовтора Тогда
					
					НовоеВремяДляПроверки = ВремяЗавершенияПоследнегоЗапуска + РасписаниеДня.ПаузаПовтора;
					
					Если ЗначениеЗаполнено(РасписаниеДня.ВремяКонца) И НовоеВремяДляПроверки > РасписаниеДня.ВремяКонца
						ИЛИ НачалоДня(НовоеВремяДляПроверки) <> НачалоДня(ВремяДляПроверки) Тогда
						
						// Время ушло за интервал
						Если Индекс < ДетальныеРасписания.ВГраница() Тогда
							Продолжить;
						КонецЕсли;
						
						ПоменятьДень = Истина;
						Прервать;
					КонецЕсли;
					
					ВремяДляПроверки = НовоеВремяДляПроверки;
					
				КонецЕсли;
			КонецЕсли;
			
			// Нашли подходящее время
			Прервать;
			
		КонецЦикла;
		
		Если ПоменятьДень Тогда
			Продолжить;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(Расписание.ВремяЗавершения)
			И ВремяДляПроверки > Расписание.ВремяЗавершения Тогда
			// В этом дне выполнять поздно.
			ПоменятьДень = Истина;
			Продолжить;
		КонецЕсли;
		
		ДатаДляПроверки = НачалоДня(ДатаДляПроверки) + (ВремяДляПроверки - НачалоДня(ВремяДляПроверки));
		
		Возврат ДатаДляПроверки;
		
	КонецЦикла;
	
КонецФункции

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

// Рассчитывает следующий момент запуска задания. 
// 
// Параметры: 
// Расписание                  - РасписаниеРегламентногоЗадания - расписание, 
//                               для которого требуется рассчитать момент следующего запуска.
// ЧасовойПояс				   - Строка.
// ДатаНачалаПоследнегоЗапуска - Дата - Дата начала последнего запуска регламентного задания. 
//                               Если дата задана, то используется для проверки таких условий как.
//                               ПериодПовтораДней, ПериодНедель, ПериодПовтораВТечениеДня. 
//                               Если дата не задана, то считается, 
//                               что задание не выполнялось ни разу и проверка этих условий не производится.
// 
// Возвращаемое значение: 
// Дата - Рассчитанный следующий момент запуска задания. 
// 
Функция ПолучитьЗапланированныйМоментЗапускаЗадания(Знач Расписание, Знач ЧасовойПояс, 
		Знач ДатаНачалаПоследнегоЗапуска = '00010101', Знач ДатаЗавершенияПоследнегоЗапуска = '00010101') Экспорт
	
	Если ПустаяСтрока(ЧасовойПояс) Тогда
		ЧасовойПояс = Неопределено;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ДатаНачалаПоследнегоЗапуска) Тогда 
		ДатаНачалаПоследнегоЗапуска = МестноеВремя(ДатаНачалаПоследнегоЗапуска, ЧасовойПояс);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ДатаЗавершенияПоследнегоЗапуска) Тогда
		ДатаЗавершенияПоследнегоЗапуска = МестноеВремя(ДатаЗавершенияПоследнегоЗапуска, ЧасовойПояс);
	КонецЕсли;
	
	ДатаРасчета = МестноеВремя(ТекущаяУниверсальнаяДата(), ЧасовойПояс);
	
	НайденнаяДата = СледующаяДатаВыполненияРасписания(Расписание, ДатаРасчета, ДатаНачалаПоследнегоЗапуска, ДатаЗавершенияПоследнегоЗапуска);
	
	Если ЗначениеЗаполнено(НайденнаяДата) Тогда
		Возврат УниверсальноеВремя(НайденнаяДата, ЧасовойПояс);
	Иначе
		Возврат НайденнаяДата;
	КонецЕсли;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Объявление служебных событий, к которым можно подключать обработчики БСП.

// Объявляет события подсистемы ОчередьЗаданий:
//
// Серверные события:
//   ПриПолученииСпискаШаблонов
//   ПриОпределенииПсевдонимовОбработчиков
//   ПриОпределенииОбработчиковОшибок
//   ПриОпределенииИспользованияРегламентныхЗаданий.
//
// См. описание этой же процедуры в модуле СтандартныеПодсистемыСервер.
Процедура ПриДобавленииСлужебныхСобытий(КлиентскиеСобытия, СерверныеСобытия) Экспорт
	
	// СЕРВЕРНЫЕ СОБЫТИЯ.
	
	// Формирует список шаблонов заданий очереди.
	//
	// Параметры:
	//  Шаблоны - Массив строк. В параметр следует добавить имена предопределенных
	//   неразделенных регламентных заданий, которые должны использоваться в качестве
	//   шаблонов для заданий очереди.
	//
	// Синтаксис:
	// Процедура ПриПолученииСпискаШаблонов(Шаблоны) Экспорт
	//
	// (То же, что ОчередьЗаданийПереопределяемый.ЗаполнитьСписокРазделенныхРегламентныхЗаданий).
	СерверныеСобытия.Добавить(
		"СтандартныеПодсистемы.РаботаВМоделиСервиса.ОчередьЗаданий\ПриПолученииСпискаШаблонов");
	
	// Заполняет соответствие имен методов их псевдонимам для вызова из очереди заданий.
	//
	// Параметры:
	//  СоответствиеИменПсевдонимам - Соответствие
	//   Ключ - Псевдоним метода, например ОчиститьОбластьДанных.
	//   Значение - Имя метода для вызова, например РаботаВМоделиСервиса.ОчиститьОбластьДанных.
	//    В качестве значения можно указать Неопределено, в этом случае считается что имя 
	//    совпадает с псевдонимом.
	//
	// Синтаксис:
	// Процедура ПриОпределенииПсевдонимовОбработчиков(СоответствиеИменПсевдонимам) Экспорт
	//
	// (То же, что ОчередьЗаданийПереопределяемый.ПолучитьРазрешенныеМетодыОчередиЗаданий).
	СерверныеСобытия.Добавить(
		"СтандартныеПодсистемы.РаботаВМоделиСервиса.ОчередьЗаданий\ПриОпределенииПсевдонимовОбработчиков");
		
	// Заполняет соответствие методов обработчиков ошибок псевдонимам методов, при возникновении
	// ошибок в которых они вызываются.
	//
	// Параметры:
	//  ОбработчикиОшибок - Соответствие
	//   Ключ - Псевдоним метода, например ОчиститьОбластьДанных.
	//   Значение - Имя метода - обработчика ошибок, для вызова при возникновении ошибки. 
	//    Обработчик ошибок вызывается в случае завершения выполнения исходного задания
	//    с ошибкой. Обработчик ошибок вызывается в той же области данных, что и исходное
	//    задание.
	//    Метод обработчика ошибок считается разрешенным к вызову механизмами очереди. 
	//    Параметры обработчика ошибок:
	//     ПараметрыЗадания - Структура - параметры задания очереди.
	//      Параметры
	//      НомерПопытки
	//      КоличествоПовторовПриАварийномЗавершении
	//      ДатаНачалаПоследнегоЗапуска.
	//     ИнформацияОбОшибке - ИнформацияОбОшибке - описание ошибки, произошедшей при
	//      выполнении задания.
	//
	// Синтаксис:
	// Процедура ПриОпределенииОбработчиковОшибок(ОбработчикиОшибок) Экспорт
	//
	// (То же, что ОчередьЗаданийПереопределяемый.ПриОпределенииОбработчиковОшибок).
	СерверныеСобытия.Добавить(
		"СтандартныеПодсистемы.РаботаВМоделиСервиса.ОчередьЗаданий\ПриОпределенииОбработчиковОшибок");
	
	// Формирует таблицу регламентных заданий с признаком использования в модели сервиса.
	//
	// Параметры:
	// ТаблицаИспользования - ТаблицаЗначений - таблица, которую необходимо
	//  заполнить регламентными заданиями и признаком использования, колонки:
	//  РегламентноеЗадание - Строка - имя предопределенного регламентного задания.
	//  Использование - Булево - Истина, если регламентное задание должно
	//   выполняться в модели сервиса. Ложь - если не должно.
	//
	// Синтаксис:
	// Процедура ПриОпределенииИспользованияРегламентныхЗаданий(ТаблицаИспользования) Экспорт
	//
	СерверныеСобытия.Добавить(
		"СтандартныеПодсистемы.РаботаВМоделиСервиса.ОчередьЗаданий\ПриОпределенииИспользованияРегламентныхЗаданий");
	
КонецПроцедуры

// См. описание этой же процедуры в модуле СтандартныеПодсистемыСервер.
Процедура ПриДобавленииОбработчиковСлужебныхСобытий(КлиентскиеОбработчики, СерверныеОбработчики) Экспорт
	
	// СЕРВЕРНЫЕ ОБРАБОТЧИКИ.
	
	СерверныеОбработчики["СтандартныеПодсистемы.ОбновлениеВерсииИБ\ПриДобавленииОбработчиковОбновления"].Добавить(
		"ОчередьЗаданийСлужебный");
	
	СерверныеОбработчики["СтандартныеПодсистемы.БазоваяФункциональность\ПриВключенииРазделенияПоОбластямДанных"].Добавить(
		"ОчередьЗаданийСлужебный");
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработчики событий подсистем БСП.

// Вызывается при включении разделения данных по областям данных.
//
Процедура ПриВключенииРазделенияПоОбластямДанных() Экспорт
	
	УстановитьИспользованиеРегламентныхЗаданий();
	
	Если Константы.МаксимальнаяДлительностьВыполненияИсполняющегоФоновогоЗадания.Получить() = 0 Тогда
		Константы.МаксимальнаяДлительностьВыполненияИсполняющегоФоновогоЗадания.Установить(600);
	КонецЕсли;
	
	Если Константы.МаксимальноеКоличествоИсполняющихФоновыхЗаданий.Получить() = 0 Тогда
		Константы.МаксимальноеКоличествоИсполняющихФоновыхЗаданий.Установить(1);
	КонецЕсли;
	
КонецПроцедуры

// Определить список справочников, доступных для загрузки с помощью подсистемы "Загрузка данных из файла".
//
// Параметры:
//  ЗагружаемыеСправочники - ТаблицаЗначений - список справочников, в которые возможна загрузка данных.
//      * ПолноеИмя          - Строка - полное имя справочника (как в метаданных).
//      * Представление      - Строка - представление справочника в списке выбора.
//      * ПрикладнаяЗагрузка - Булево - если Истина, значит справочник использует собственный алгоритм загрузки и
//                                      в модуле менеджера справочника определены функции.
//
Процедура ПриОпределенииСправочниковДляЗагрузкиДанных(ЗагружаемыеСправочники) Экспорт
	
	// Загрузка в справочник ОчередьЗаданий запрещена.
	СтрокаТаблицы = ЗагружаемыеСправочники.Найти(Метаданные.Справочники.ОчередьЗаданий.ПолноеИмя(), "ПолноеИмя");
	Если СтрокаТаблицы <> Неопределено Тогда 
		ЗагружаемыеСправочники.Удалить(СтрокаТаблицы);
	КонецЕсли;
	
	// Загрузка в справочник ШаблоныЗаданийОчереди запрещена.
	СтрокаТаблицы = ЗагружаемыеСправочники.Найти(Метаданные.Справочники.ШаблоныЗаданийОчереди.ПолноеИмя(), "ПолноеИмя");
	Если СтрокаТаблицы <> Неопределено Тогда 
		ЗагружаемыеСправочники.Удалить(СтрокаТаблицы);
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработчики условных вызовов в эту подсистему.

// Возвращает менеджер справочника ОчередьЗаданий.
Функция СправочникОчередьЗаданий() Экспорт
	
	Возврат ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени("Справочник.ОчередьЗаданий");
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

////////////////////////////////////////////////////////////////////////////////
// Экспортные служебные процедуры и функции.

// Производит планирование выполнения заданий из РС ОчередьЗаданий.
// 
Процедура ПланированиеОбработкиЗаданий() Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		Возврат;
	КонецЕсли;
	
	// Вызов ПриНачалеВыполненияРегламентногоЗадания не используется,
	// т.к. необходимые действия выполняются в частном порядке.
	
	// Выбираем события в состояниях Выполняется, Завершено, НеЗапланировано, ОшибкаВыполнения.
	Запрос = Новый Запрос;
	
	СправочникиЗаданий = ОчередьЗаданийСлужебныйПовтИсп.ПолучитьСправочникиЗаданий();
	ТекстЗапроса = "";
	Для Каждого СправочникЗаданий Из СправочникиЗаданий Цикл
		
		Если Не ПустаяСтрока(ТекстЗапроса) Тогда
			
			ТекстЗапроса = ТекстЗапроса + "
			|
			|ОБЪЕДИНИТЬ ВСЕ
			|"
			
		КонецЕсли;
		
		Если ОбщегоНазначенияПовтИсп.ЭтоРазделеннаяКонфигурация() И ОбщегоНазначенияПовтИсп.ЭтоРазделенныйОбъектМетаданных(СправочникЗаданий.СоздатьЭлемент().Метаданные().ПолноеИмя(), ОбщегоНазначенияПовтИсп.РазделительВспомогательныхДанных()) Тогда
			
			ТекстЗапроса = ТекстЗапроса + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			"ВЫБРАТЬ
			|	Очередь.ОбластьДанныхВспомогательныеДанные КАК ОбластьДанных,
			|	Очередь.Ссылка КАК Идентификатор,
			|	ЕСТЬNULL(Очередь.Шаблон, НЕОПРЕДЕЛЕНО) КАК Шаблон,
			|	ЕСТЬNULL(ЧасовыеПояса.Значение, """") КАК ЧасовойПояс,
			|	ВЫБОР
			|		КОГДА Очередь.Шаблон = ЗНАЧЕНИЕ(Справочник.ШаблоныЗаданийОчереди.ПустаяСсылка)
			|			ТОГДА Очередь.Расписание
			|		ИНАЧЕ Очередь.Шаблон.Расписание
			|	КОНЕЦ КАК Расписание,
			|	ВЫБОР
			|		КОГДА Очередь.Шаблон = ЗНАЧЕНИЕ(Справочник.ШаблоныЗаданийОчереди.ПустаяСсылка)
			|			ТОГДА Очередь.КоличествоПовторовПриАварийномЗавершении
			|		ИНАЧЕ Очередь.Шаблон.КоличествоПовторовПриАварийномЗавершении
			|	КОНЕЦ КАК КоличествоПовторовПриАварийномЗавершении,
			|	ВЫБОР
			|		КОГДА Очередь.Шаблон = ЗНАЧЕНИЕ(Справочник.ШаблоныЗаданийОчереди.ПустаяСсылка)
			|			ТОГДА Очередь.ИнтервалПовтораПриАварийномЗавершении
			|		ИНАЧЕ Очередь.Шаблон.ИнтервалПовтораПриАварийномЗавершении
			|	КОНЕЦ КАК ИнтервалПовтораПриАварийномЗавершении
			|ИЗ
			|	%1 КАК Очередь
			|		ЛЕВОЕ СОЕДИНЕНИЕ Константа.ЧасовойПоясОбластиДанных КАК ЧасовыеПояса
			|		ПО Очередь.ОбластьДанныхВспомогательныеДанные = ЧасовыеПояса.ОбластьДанныхВспомогательныеДанные
			|ГДЕ
			|	Очередь.СостояниеЗадания В (ЗНАЧЕНИЕ(Перечисление.СостоянияЗаданий.Выполняется), ЗНАЧЕНИЕ(Перечисление.СостоянияЗаданий.Завершено), ЗНАЧЕНИЕ(Перечисление.СостоянияЗаданий.НеЗапланировано), ЗНАЧЕНИЕ(Перечисление.СостоянияЗаданий.ОшибкаВыполнения))"
			, СправочникЗаданий.ПустаяСсылка().Метаданные().ПолноеИмя());
			
		Иначе
			
			ТекстЗапроса = ТекстЗапроса + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			"ВЫБРАТЬ
			|	-1 КАК ОбластьДанных,
			|	Очередь.Ссылка КАК Идентификатор,
			|	НЕОПРЕДЕЛЕНО КАК Шаблон,
			|	"""" КАК ЧасовойПояс,
			|	Очередь.Расписание КАК Расписание,
			|	Очередь.КоличествоПовторовПриАварийномЗавершении КАК КоличествоПовторовПриАварийномЗавершении,
			|	Очередь.ИнтервалПовтораПриАварийномЗавершении КАК ИнтервалПовтораПриАварийномЗавершении
			|ИЗ
			|	%1 КАК Очередь
			|ГДЕ
			|	Очередь.СостояниеЗадания В (ЗНАЧЕНИЕ(Перечисление.СостоянияЗаданий.Выполняется), ЗНАЧЕНИЕ(Перечисление.СостоянияЗаданий.Завершено), ЗНАЧЕНИЕ(Перечисление.СостоянияЗаданий.НеЗапланировано), ЗНАЧЕНИЕ(Перечисление.СостоянияЗаданий.ОшибкаВыполнения))"
			, СправочникЗаданий.ПустаяСсылка().Метаданные().ПолноеИмя());
			
		КонецЕсли;
		
	КонецЦикла;
	
	Запрос.Текст = ТекстЗапроса;
	Результат = ОбщегоНазначения.ВыполнитьЗапросВнеТранзакции(Запрос);
	Выборка = Результат.Выбрать();
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса.БазоваяФункциональностьВМоделиСервиса") Тогда
		МодульРаботаВМоделиСервиса = ОбщегоНазначения.ОбщийМодуль("РаботаВМоделиСервиса");
	Иначе
		МодульРаботаВМоделиСервиса = Неопределено;
	КонецЕсли;
	
	Пока Выборка.Следующий() Цикл
		
		Попытка
			ЗаблокироватьДанныеДляРедактирования(Выборка.Идентификатор);
		Исключение
			// Запись заблокирована, перейти к следующей.
			Продолжить;
		КонецПопытки;
		
		// Проверка блокировки области.
		Если МодульРаботаВМоделиСервиса <> Неопределено
			И Выборка.ОбластьДанных <> -1 
			И МодульРаботаВМоделиСервиса.ОбластьДанныхЗаблокирована(Выборка.ОбластьДанных) Тогда
			
			// Область заблокирована, перейти к следующей записи.
			Продолжить;
		КонецЕсли;
		
		// Перепланируем завершившиеся регламентные задания и аварийно завершившиеся фоновые, удаляем выполненные фоновые.
		ЗапланироватьЗадание(Выборка);
		
	КонецЦикла;

	// Вычисление количество требуемых исполняющих фоновых заданий.
	КоличествоЗапускаемыхФоновыхЗаданий = КоличествоИсполняющихФоновыхЗаданийКЗапуску();
	
	// Запуск исполняющих фоновых заданий.
	ЗапуститьИсполняющееФоновоеЗадание(КоличествоЗапускаемыхФоновыхЗаданий);
	
КонецПроцедуры

// Процедура выполняет задания из РС ОчередьЗаданий.
// 
// Параметры: 
// КлючФоновогоЗадания - УникальныйИдентификатор - ключ необходим 
//                       для поиска текущего фонового задания.
//
Процедура ОбработатьОчередьЗаданий(КлючФоновогоЗадания) Экспорт
	
	// Вызов ПриНачалеВыполненияРегламентногоЗадания не используется,
	// т.к. необходимые действия выполняются в частном порядке.
	
	НайденноеФоновоеЗадание = ФоновыеЗадания.ПолучитьФоновыеЗадания(Новый Структура("Ключ", КлючФоновогоЗадания));
	Если НайденноеФоновоеЗадание.Количество() = 1 Тогда
		ИсполняющееФоновоеЗадание = НайденноеФоновоеЗадание[0];
	Иначе
		Возврат;
	КонецЕсли;
	
	МожноВыполнять = Истина;
	НачалоВыполнения = ТекущаяУниверсальнаяДата();
	
	МаксимальнаяДлительностьВыполненияИсполняющегоФоновогоЗадания = 
		Константы.МаксимальнаяДлительностьВыполненияИсполняющегоФоновогоЗадания.Получить();
	МаксимальноеКоличествоИсполняющихФоновыхЗаданий =
		Константы.МаксимальноеКоличествоИсполняющихФоновыхЗаданий.Получить();
	
	Запрос = Новый Запрос;
	
	СправочникиЗаданий = ОчередьЗаданийСлужебныйПовтИсп.ПолучитьСправочникиЗаданий();
	ТекстЗапроса = "";
	ТекстЗапросаБлокировки = "";
	Для Каждого СправочникЗаданий Из СправочникиЗаданий Цикл
		
		ПерваяСтрока = ПустаяСтрока(ТекстЗапроса);
		
		Если Не ПерваяСтрока Тогда
			
			ТекстЗапроса = ТекстЗапроса + "
			|
			|ОБЪЕДИНИТЬ ВСЕ
			|"
			
		КонецЕсли;
		
		Если ОбщегоНазначенияПовтИсп.ЭтоРазделеннаяКонфигурация() И ОбщегоНазначения.ЭтоРазделенныйОбъектМетаданных(СправочникЗаданий.СоздатьЭлемент().Метаданные().ПолноеИмя(), ОбщегоНазначенияПовтИсп.РазделительВспомогательныхДанных()) Тогда
			
			Если ПустаяСтрока(ТекстЗапросаБлокировки) Тогда
				
				ТекстЗапросаБлокировки = 
				"ВЫБРАТЬ
				|	Блокировки.ОбластьДанныхВспомогательныеДанные КАК ОбластьДанныхВспомогательныеДанные
				|ПОМЕСТИТЬ Блокировки
				|ИЗ
				|	РегистрСведений.БлокировкиСеансовОбластейДанных КАК Блокировки
				|ГДЕ
				|	(Блокировки.НачалоБлокировки > &ТекущаяУниверсальнаяДата
				|			ИЛИ Блокировки.КонецБлокировки <> ДАТАВРЕМЯ(1, 1, 1)
				|				И Блокировки.КонецБлокировки < &ТекущаяУниверсальнаяДата)
				|;
				|
				|////////////////////////////////////////////////////////////////////////////////
				|";
				
			КонецЕсли;
			
			ТекстЗапроса = ТекстЗапроса + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			"ВЫБРАТЬ
			|	Очередь.ОбластьДанныхВспомогательныеДанные КАК ОбластьДанных,
			|	Очередь.Ссылка КАК Идентификатор,
			|	Очередь.Использование КАК Использование,
			|	Очередь.ЗапланированныйМоментЗапуска КАК ЗапланированныйМоментЗапуска,
			|	Очередь.ИсполняющееФоновоеЗадание КАК ИсполняющееФоновоеЗадание,
			|	Очередь.ЭксклюзивноеВыполнение КАК ЭксклюзивноеВыполнение,
			|	Очередь.НомерПопытки КАК НомерПопытки,
			|	Очередь.Шаблон КАК Шаблон,
			|	ЕСТЬNULL(Очередь.Шаблон.Ссылка, НЕОПРЕДЕЛЕНО) КАК СсылкаШаблона,
			|	ЕСТЬNULL(ЧасовыеПояса.Значение, """") КАК ЧасовойПояс,
			|	ВЫБОР
			|		КОГДА Очередь.Шаблон = ЗНАЧЕНИЕ(Справочник.ШаблоныЗаданийОчереди.ПустаяСсылка)
			|			ТОГДА Очередь.Расписание
			|		ИНАЧЕ Очередь.Шаблон.Расписание
			|	КОНЕЦ КАК Расписание,
			|	ВЫБОР
			|		КОГДА Очередь.Шаблон = ЗНАЧЕНИЕ(Справочник.ШаблоныЗаданийОчереди.ПустаяСсылка)
			|			ТОГДА Очередь.ИмяМетода
			|		ИНАЧЕ Очередь.Шаблон.ИмяМетода
			|	КОНЕЦ КАК ИмяМетода,
			|	Очередь.Параметры КАК Параметры,
			|	Очередь.ДатаНачалаПоследнегоЗапуска КАК ДатаНачалаПоследнегоЗапуска,
			|	Очередь.ДатаЗавершенияПоследнегоЗапуска КАК ДатаЗавершенияПоследнегоЗапуска
			|ИЗ
			|	%1 КАК Очередь
			|		ЛЕВОЕ СОЕДИНЕНИЕ Константа.ЧасовойПоясОбластиДанных КАК ЧасовыеПояса
			|		ПО Очередь.ОбластьДанныхВспомогательныеДанные = ЧасовыеПояса.ОбластьДанныхВспомогательныеДанные
			|ГДЕ
			|	Очередь.Использование
			|	И Очередь.ЗапланированныйМоментЗапуска <= &ТекущаяУниверсальнаяДата
			|	И Очередь.СостояниеЗадания = ЗНАЧЕНИЕ(Перечисление.СостоянияЗаданий.Запланировано)
			|	И Очередь.ЭксклюзивноеВыполнение
			|
			|ОБЪЕДИНИТЬ ВСЕ
			|
			|ВЫБРАТЬ
			|	Очередь.ОбластьДанныхВспомогательныеДанные,
			|	Очередь.Ссылка,
			|	Очередь.Использование,
			|	Очередь.ЗапланированныйМоментЗапуска,
			|	Очередь.ИсполняющееФоновоеЗадание,
			|	Очередь.ЭксклюзивноеВыполнение,
			|	Очередь.НомерПопытки,
			|	Очередь.Шаблон,
			|	ЕСТЬNULL(Очередь.Шаблон.Ссылка, НЕОПРЕДЕЛЕНО),
			|	ЕСТЬNULL(ЧасовыеПояса.Значение, """"),
			|	ВЫБОР
			|		КОГДА Очередь.Шаблон = ЗНАЧЕНИЕ(Справочник.ШаблоныЗаданийОчереди.ПустаяСсылка)
			|			ТОГДА Очередь.Расписание
			|		ИНАЧЕ Очередь.Шаблон.Расписание
			|	КОНЕЦ,
			|	ВЫБОР
			|		КОГДА Очередь.Шаблон = ЗНАЧЕНИЕ(Справочник.ШаблоныЗаданийОчереди.ПустаяСсылка)
			|			ТОГДА Очередь.ИмяМетода
			|		ИНАЧЕ Очередь.Шаблон.ИмяМетода
			|	КОНЕЦ,
			|	Очередь.Параметры,
			|	Очередь.ДатаНачалаПоследнегоЗапуска,
			|	Очередь.ДатаЗавершенияПоследнегоЗапуска
			|ИЗ
			|	%1 КАК Очередь
			|		ЛЕВОЕ СОЕДИНЕНИЕ Блокировки КАК Блокировки
			|		ПО Очередь.ОбластьДанныхВспомогательныеДанные = Блокировки.ОбластьДанныхВспомогательныеДанные
			|		ЛЕВОЕ СОЕДИНЕНИЕ Константа.ЧасовойПоясОбластиДанных КАК ЧасовыеПояса
			|		ПО Очередь.ОбластьДанныхВспомогательныеДанные = ЧасовыеПояса.ОбластьДанныхВспомогательныеДанные
			|ГДЕ
			|	Очередь.Использование
			|	И Очередь.ЗапланированныйМоментЗапуска <= &ТекущаяУниверсальнаяДата
			|	И Очередь.СостояниеЗадания = ЗНАЧЕНИЕ(Перечисление.СостоянияЗаданий.Запланировано)
			|	И НЕ Очередь.ЭксклюзивноеВыполнение
			|	И Блокировки.ОбластьДанныхВспомогательныеДанные ЕСТЬ NULL "
			, СправочникЗаданий.ПустаяСсылка().Метаданные().ПолноеИмя());
			
		Иначе
			
			ТекстЗапроса = ТекстЗапроса + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			"ВЫБРАТЬ
			|	-1 КАК ОбластьДанных,
			|	Очередь.Ссылка КАК Идентификатор,
			|	Очередь.Использование КАК Использование,
			|	Очередь.ЗапланированныйМоментЗапуска КАК ЗапланированныйМоментЗапуска,
			|	Очередь.ИсполняющееФоновоеЗадание КАК ИсполняющееФоновоеЗадание,
			|	Очередь.ЭксклюзивноеВыполнение КАК ЭксклюзивноеВыполнение,
			|	Очередь.НомерПопытки КАК НомерПопытки,
			|	НЕОПРЕДЕЛЕНО КАК Шаблон,
			|	НЕОПРЕДЕЛЕНО КАК СсылкаШаблона,
			|	"""" КАК ЧасовойПояс,
			|	Очередь.Расписание КАК Расписание,
			|	Очередь.ИмяМетода КАК ИмяМетода,
			|	Очередь.Параметры КАК Параметры,
			|	Очередь.ДатаНачалаПоследнегоЗапуска КАК ДатаНачалаПоследнегоЗапуска,
			|	Очередь.ДатаЗавершенияПоследнегоЗапуска КАК ДатаЗавершенияПоследнегоЗапуска
			|ИЗ %1 КАК Очередь
			|ГДЕ
			|	Очередь.Использование
			|	И Очередь.ЗапланированныйМоментЗапуска <= &ТекущаяУниверсальнаяДата
			|	И Очередь.СостояниеЗадания = ЗНАЧЕНИЕ(Перечисление.СостоянияЗаданий.Запланировано)"
			, СправочникЗаданий.ПустаяСсылка().Метаданные().ПолноеИмя());
			
		КонецЕсли;
		
	КонецЦикла;
	
	ТекстЗапроса = ТекстЗапросаБлокировки +
		"ВЫБРАТЬ ПЕРВЫЕ 111
		|	ВложенныйЗапрос.ОбластьДанных КАК ОбластьДанных,
		|	ВложенныйЗапрос.Идентификатор КАК Идентификатор,
		|	ВложенныйЗапрос.Использование КАК Использование,
		|	ВложенныйЗапрос.ЗапланированныйМоментЗапуска КАК ЗапланированныйМоментЗапуска,
		|	ВложенныйЗапрос.ИсполняющееФоновоеЗадание КАК ИсполняющееФоновоеЗадание,
		|	ВложенныйЗапрос.ЭксклюзивноеВыполнение КАК ЭксклюзивноеВыполнение,
		|	ВложенныйЗапрос.НомерПопытки КАК НомерПопытки,
		|	ВложенныйЗапрос.Шаблон КАК Шаблон,
		|	ВложенныйЗапрос.СсылкаШаблона КАК СсылкаШаблона,
		|	ВложенныйЗапрос.ЧасовойПояс КАК ЧасовойПояс,
		|	ВложенныйЗапрос.Расписание КАК Расписание,
		|	ВложенныйЗапрос.ИмяМетода КАК ИмяМетода,
		|	ВложенныйЗапрос.Параметры КАК Параметры,
		|	ВложенныйЗапрос.ДатаНачалаПоследнегоЗапуска КАК ДатаНачалаПоследнегоЗапуска,
		|	ВложенныйЗапрос.ДатаЗавершенияПоследнегоЗапуска КАК ДатаЗавершенияПоследнегоЗапуска
		|ИЗ
		|	(" +  ТекстЗапроса + ") КАК ВложенныйЗапрос
		|
		|УПОРЯДОЧИТЬ ПО
		|	ЭксклюзивноеВыполнение УБЫВ,
		|	ЗапланированныйМоментЗапуска,
		|	ВложенныйЗапрос.ДатаЗавершенияПоследнегоЗапуска,
		|	Идентификатор"; 
	
	Запрос.Текст = ТекстЗапроса;
	РазмерВыборкиТекст = Формат(МаксимальноеКоличествоИсполняющихФоновыхЗаданий * 3, "ЧН=; ЧГ=");
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "111", РазмерВыборкиТекст);
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса.БазоваяФункциональностьВМоделиСервиса") Тогда
		МодульРаботаВМоделиСервиса = ОбщегоНазначения.ОбщийМодуль("РаботаВМоделиСервиса");
	Иначе
		МодульРаботаВМоделиСервиса = Неопределено;
	КонецЕсли;
	
	Пока МожноВыполнять Цикл 
		Запрос.УстановитьПараметр("ТекущаяУниверсальнаяДата", ТекущаяУниверсальнаяДата());
		
		Выборка = ОбщегоНазначения.ВыполнитьЗапросВнеТранзакции(Запрос).Выбрать();
		
		БлокировкаУстановлена = Ложь;
		Пока Выборка.Следующий() Цикл 
			Попытка
				
				ЗаблокироватьДанныеДляРедактирования(Выборка.Идентификатор);
				
				// Проверка блокировки области.
				Если МодульРаботаВМоделиСервиса <> Неопределено
					И Выборка.ОбластьДанных <> -1 
					И МодульРаботаВМоделиСервиса.ОбластьДанныхЗаблокирована(Выборка.ОбластьДанных) Тогда
					
					РазблокироватьДанныеДляРедактирования(Выборка.Идентификатор);
					
					// Область заблокирована, перейти к следующей записи.
					Продолжить;
				КонецЕсли;
				
				Если ЗначениеЗаполнено(Выборка.Шаблон)
						И Выборка.СсылкаШаблона = Неопределено Тогда
					
					ШаблонСообщения = НСтр("ru = 'На найден шаблон задания очереди с идентификатором %1'");
					ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, Выборка.Шаблон);
					ЗаписьЖурналаРегистрации(НСтр("ru = 'Очередь заданий.Выполнение'", 
						ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()), 
						УровеньЖурналаРегистрации.Ошибка,
						,
						,
						ТекстСообщения);
					
					РазблокироватьДанныеДляРедактирования(Выборка.Идентификатор);
					Продолжить;
				КонецЕсли;
				
				БлокировкаУстановлена = Истина;
				Прервать;
			Исключение
				// Не удалось установить блокировку.
				БлокировкаУстановлена = Ложь;
			КонецПопытки;
		КонецЦикла;
		
		Если Не БлокировкаУстановлена Тогда 
			Возврат;
		КонецЕсли;
		
		Расписание = Выборка.Расписание.Получить();
		Если Расписание <> Неопределено Тогда
			// Проверка попадания в допустимые интервалы очереди.
			ЧасовойПояс = Выборка.ЧасовойПояс;
			
			Если ПустаяСтрока(ЧасовойПояс) Тогда
				ЧасовойПояс = Неопределено;
			КонецЕсли;
			
			ВремяОбласти = МестноеВремя(ТекущаяУниверсальнаяДата(), ЧасовойПояс);
			Просрочено = НЕ Расписание.ТребуетсяВыполнение(ВремяОбласти);
		Иначе
			Просрочено = Ложь;
		КонецЕсли;
		
		Если Просрочено Тогда
			// Требуется перепланировать задание.
			НачатьТранзакцию();
			Попытка
				Блокировка = Новый БлокировкаДанных;
				ЭлементБлокировки = Блокировка.Добавить(Выборка.Идентификатор.Метаданные().ПолноеИмя());
				ЭлементБлокировки.УстановитьЗначение("Ссылка", Выборка.Идентификатор);
				
				Если Выборка.ОбластьДанных <> -1 Тогда
					ОбщегоНазначения.УстановитьРазделениеСеанса(Истина, Выборка.ОбластьДанных);
				КонецЕсли;
				Блокировка.Заблокировать();
				
				Задание = Выборка.Идентификатор.ПолучитьОбъект();
				Задание.СостояниеЗадания = Перечисления.СостоянияЗаданий.НеЗапланировано;
				ОбщегоНазначения.ЗаписатьВспомогательныеДанные(Задание);
				ЗафиксироватьТранзакцию();
			Исключение
				ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
				ОтменитьТранзакцию();
				ВызватьИсключение;
			КонецПопытки;
			ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
		Иначе
			ВыполнитьЗаданиеОчереди(Выборка.Идентификатор, ИсполняющееФоновоеЗадание, Выборка.Шаблон, Выборка.ИмяМетода);
		КонецЕсли;
		
		РазблокироватьДанныеДляРедактирования(Выборка.Идентификатор);
		
		// Проверка возможности дальнейшего выполнения.
		ДлительностьВыполнения = ТекущаяУниверсальнаяДата() - НачалоВыполнения;
		Если ДлительностьВыполнения > МаксимальнаяДлительностьВыполненияИсполняющегоФоновогоЗадания Тогда
			МожноВыполнять = Ложь;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Служебная процедура, которая вызывается для выполнения обработчика ошибок задания в случае,
// когда процесс, исполняющий задание не смог завершить выполнение самостоятельно.
//
// Параметры:
// Задание - СправочникСсылка - ссылка на задание, обработчик ошибки которого необходимо выполнить.
// ИнформацияОбОшибкеВыполненияЗадания - ИнформацияОбОшибке - информация об ошибке, с которой завершилось задание.
//
Процедура ОбработатьОшибку(Знач Задание, Знач ИнформацияОбОшибкеВыполненияЗадания = Неопределено) Экспорт
	
	Попытка
		
		ЗаблокироватьДанныеДляРедактирования(Задание);
		
		ПараметрыОбработчикаОшибок = ПолучитьПараметрыОбработчикаОшибок(Задание, ИнформацияОбОшибкеВыполненияЗадания);
		Если ПараметрыОбработчикаОшибок.ОбработчикСуществует Тогда
			ВыполнитьМетодКонфигурации(ПараметрыОбработчикаОшибок.ИмяМетода, ПараметрыОбработчикаОшибок.ПараметрыВызоваОбработчика);
		КонецЕсли;
		
	Исключение
		
		ШаблонКомментария = НСтр("ru = 'Ошибка при выполнении обработчика ошибок
			|Псевдоним метода: %1
			|Метод обработчика ошибок: %2
			|По причине:
			|%3'");
		ТекстКомментария = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонКомментария,
			ПараметрыОбработчикаОшибок.ИмяМетодаЗадания,
			ПараметрыОбработчикаОшибок.ИмяМетода,
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'Очередь регламентных заданий.Ошибка обработчика ошибок'", 
				ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка,
			,
			,
			ТекстКомментария);
			
	КонецПопытки;
	
	Если ОбщегоНазначения.СсылкаСуществует(Задание)
		И Задание.СостояниеЗадания = Перечисления.СостоянияЗаданий.ОбработкаОшибкиПриАварийномЗавершении Тогда
	
		ЗаданиеОбъект = Задание.ПолучитьОбъект();
		ЗаданиеОбъект.СостояниеЗадания = Перечисления.СостоянияЗаданий.ОшибкаВыполнения;
		ОбщегоНазначения.ЗаписатьВспомогательныеДанные(ЗаданиеОбъект);
	
	КонецЕсли;
	
	РазблокироватьДанныеДляРедактирования(Задание);
	
КонецПроцедуры

// Служебная процедура, которая снимает задания обработчика ошибок и свои собственные. Необходима для случая, когда
// задание исполнение "ОбработатьОшибку" не смогло завершиться.
//
// Параметры:
// ПараметрыВызова - Массив - Массив параметров, который был передан заданию, ошибку выполнения которого мы обрабатываем
//                            используется только для определения задания, ошибку выполнения которого мы обрабатываем.
// ИнформацияОбОшибке - ОписаниеОшибки - Не используется, необходимо только потому, что этот параметр должен
//                                       присутствовать  в обработчике ошибок.
// СчетчикРекурсии - Число - Используется для подсчета количества созданных заданий снятия заданий.
//
Процедура СнятьЗаданияОбработкиОшибок(Знач ПараметрыВызова, Знач ИнформацияОбОшибке = Неопределено, Знач СчетчикРекурсии = 1) Экспорт
	
	НачатьТранзакцию();
	Попытка
		
		ЗаданиеСсылка = ПараметрыВызова.Параметры[0];
		
		Если Не ОбщегоНазначения.СсылкаСуществует(ЗаданиеСсылка) Тогда
		
			ОтменитьТранзакцию();
			Возврат;
		
		КонецЕсли;
		
		Задание = ЗаданиеСсылка.ПолучитьОбъект();
		
		ЗаблокироватьДанныеДляРедактирования(ЗаданиеСсылка);
		
		Задание.СостояниеЗадания = Перечисления.СостоянияЗаданий.ОшибкаВыполнения;
		ОбщегоНазначения.ЗаписатьВспомогательныеДанные(Задание);
		
		ПараметрыОбработчикаОшибок = ПолучитьПараметрыОбработчикаОшибок(Задание);
		Если ПараметрыОбработчикаОшибок.ИмяМетода = "ОчередьЗаданийСлужебный.СнятьЗаданияОбработкиОшибок" Тогда
			
			СнятьЗаданияОбработкиОшибок(ПараметрыОбработчикаОшибок.ПараметрыВызоваОбработчика[0], ИнформацияОбОшибке, СчетчикРекурсии + 1);
			
		Иначе
			
			ШаблонКомментария = НСтр("ru = 'Был выполнен обработчик снятие заданий.
			|Псевдоним метода: %1
			|Уровень рекурсии: %2'");
			ТекстКомментария = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонКомментария,
				ПараметрыОбработчикаОшибок.ИмяМетодаЗадания,
				СчетчикРекурсии);
				
			ЗаписьЖурналаРегистрации(
				НСтр("ru = 'Очередь регламентных заданий.Снятие заданий обработки ошибок'",
					ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Информация,
				,
				,
				ТекстКомментария);
			
		КонецЕсли;
			
		ЗафиксироватьТранзакцию();
		
	Исключение
		
		ОтменитьТранзакцию();
	
	КонецПопытки;
	
	РазблокироватьДанныеДляРедактирования(ЗаданиеСсылка);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Локальные служебные процедуры и функции.

// Метод предназначен для вызова методов обработчиков задания и ошибок.
//
// Параметры: 
// ИмяМетода - Строка - Имя вызываемого метода.
// Параметры - Массив - Значение параметров, передаваемых методу, в порядке
//                       их следования в вызываемом методе.
//
Процедура ВыполнитьМетодКонфигурации(ИмяМетода, Параметры = Неопределено)

	Если ОбщегоНазначенияПовтИсп.РазделениеВключено() И ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		РазделительУстановлен = Истина;
		ЗначениеРазделителя = РаботаВМоделиСервиса.ЗначениеРазделителяСеанса();
	Иначе
		РазделительУстановлен = Ложь;
	КонецЕсли;
	
	Если ТранзакцияАктивна() Тогда
		
		ТекстСообщенияОбОшибке = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Перед стартом выполнения обработчика %1 есть активные транзакции!'"),
				ИмяМетода);
			
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Очередь регламентных заданий.Выполнение'", 
			ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка,
			,
			,
			ТекстСообщенияОбОшибке);
			
		ВызватьИсключение ТекстСообщенияОбОшибке;
		
	КонецЕсли;
	
	Попытка
		
		РаботаВБезопасномРежиме.ВыполнитьМетодКонфигурации(ИмяМетода, Параметры);
		
		Если ТранзакцияАктивна() Тогда
		
			Пока ТранзакцияАктивна() Цикл
				ОтменитьТранзакцию();
			КонецЦикла;
			
			ШаблонСообщения = НСтр("ru = 'По завершении выполнения обработчика %1 не была закрыта транзакция'");
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, ИмяМетода);
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Очередь регламентных заданий.Выполнение'", 
				ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка, 
				,
				, 
				ТекстСообщения);
			
		КонецЕсли;
		
		Если Не(РазделительУстановлен) И ОбщегоНазначения.ИспользованиеРазделителяСеанса() Тогда
			
			ТекстСообщенияОбОшибке = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'По завершении выполнения обработчика %1 не было выключено разделение сеанса!'"),
				ИмяМетода);
			
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Очередь регламентных заданий.Выполнение'", 
				ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка,
				,
				,
				ТекстСообщенияОбОшибке);
			
			ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
			
		ИначеЕсли РазделительУстановлен И ЗначениеРазделителя <> РаботаВМоделиСервиса.ЗначениеРазделителяСеанса() Тогда
			
			ТекстСообщенияОбОшибке = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'По завершении выполнения обработчика %1 было изменено значение разделителя сеанса!'"),
				ИмяМетода);
			
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Очередь регламентных заданий.Выполнение'", 
				ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка,
				,
				,
				ТекстСообщенияОбОшибке);
			
			ОбщегоНазначения.УстановитьРазделениеСеанса(Истина,ЗначениеРазделителя);
			
		КонецЕсли;
		
		
	Исключение
		
		Пока ТранзакцияАктивна() Цикл
			ОтменитьТранзакцию();
		КонецЦикла;
		
		Если Не(РазделительУстановлен) И ОбщегоНазначения.ИспользованиеРазделителяСеанса() Тогда
			ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
		ИначеЕсли РазделительУстановлен И ЗначениеРазделителя <> РаботаВМоделиСервиса.ЗначениеРазделителяСеанса() Тогда
			ОбщегоНазначения.УстановитьРазделениеСеанса(Истина,ЗначениеРазделителя);
		КонецЕсли;
		
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

// Формирует и возвращает информацию об ошибке по тексту ее описания.
Функция КонструкторИнформацииОбОшибке(ТекстОшибки)

	Попытка
			
		ВызватьИсключение ТекстОшибки;
			
	Исключение
		Информация = ИнформацияОбОшибке();
	КонецПопытки;
	
	Возврат Информация;

КонецФункции

// Получает по ссылке на задание параметры для запуска обработчика ошибок.
//
// Параметры:
//  Задание  - СправочникСсылка.ОчередьЗаданий или СправочникСсылка.ОчередьЗаданийОбластейДанных - 
//             Ссылка на задание, по которой необходимо получить параметры обработчика ошибок.
//
// Возвращаемое значение:
//   Структура - Параметры для запуска обработчика ошибок.
//      ИмяМетода - Строка, имя метода обработчика ошибок, который должен быть запущен.
//      ИмяМетодаЗадания - Строка, имя метода задания, который должен был выполниться,
//      ПараметрыВызоваОбработчика - массив с параметрами, которые будут переданы процедуре обработки ошибок.
//      ОбработчикСуществует - Булево, обработчик ошибок для данного задания существует.
//      Задание - СправочникСсылка.ОчередьЗаданий или СправочникСсылка.ОчередьЗаданийОбластейДанных -
//                Ссылка на задание, которое было передано как входящий параметр.
//
Функция ПолучитьПараметрыОбработчикаОшибок(Знач Задание,Знач ИнформацияОбОшибкеВыполненияЗадания = Неопределено)

	Результат = Новый Структура("ИмяМетода,ИмяМетодаЗадания,ПараметрыВызоваОбработчика,ОбработчикСуществует,Задание");
	Результат.Задание = Задание.Ссылка;
	
	Если ОбщегоНазначенияПовтИсп.ЭтоРазделенныйОбъектМетаданных(Задание.Метаданные().ПолноеИмя(), 
			ОбщегоНазначенияПовтИсп.РазделительВспомогательныхДанных()) 
		И ЗначениеЗаполнено(Задание.Шаблон) Тогда
		
		Результат.ИмяМетодаЗадания = Задание.Шаблон.ИмяМетода;
		
	Иначе
		
		Результат.ИмяМетодаЗадания = Задание.ИмяМетода;
		
	КонецЕсли;
	
	ИмяМетодаОбработчикаОшибки = 
		ОчередьЗаданийСлужебныйПовтИсп.СоответствиеОбработчиковОшибокПсевдонимам().Получить(ВРег(Результат.ИмяМетодаЗадания));
	Результат.ИмяМетода = ИмяМетодаОбработчикаОшибки;
	Результат.ОбработчикСуществует = ЗначениеЗаполнено(Результат.ИмяМетода);
	Если Результат.ОбработчикСуществует Тогда
		ПараметрыЗадания = Новый Структура;
		ПараметрыЗадания.Вставить("Параметры", Задание.Параметры.Получить());
		ПараметрыЗадания.Вставить("НомерПопытки", Задание.НомерПопытки);
		ПараметрыЗадания.Вставить("КоличествоПовторовПриАварийномЗавершении", Задание.КоличествоПовторовПриАварийномЗавершении);
		ПараметрыЗадания.Вставить("ДатаНачалаПоследнегоЗапуска", Задание.ДатаНачалаПоследнегоЗапуска);
		
		Если ИнформацияОбОшибкеВыполненияЗадания = Неопределено Тогда
			
			ИсполняющееФоновоеЗадание = ФоновыеЗадания.НайтиПоУникальномуИдентификатору(Задание.ИсполняющееФоновоеЗадание);
			
			Если ИсполняющееФоновоеЗадание <> Неопределено И ИсполняющееФоновоеЗадание.ИнформацияОбОшибке <> Неопределено Тогда
				
				ИнформацияОбОшибкеВыполненияЗадания = ИсполняющееФоновоеЗадание.ИнформацияОбОшибке;
				
			КонецЕсли;
			
		КонецЕсли;
		
		Если ИнформацияОбОшибкеВыполненияЗадания = Неопределено Тогда
			
			ИнформацияОбОшибкеВыполненияЗадания = КонструкторИнформацииОбОшибке(НСтр("ru = 'Задание завершилось с неизвестной ошибкой, возможно вызванной падением рабочего процесса.'"));
			
		КонецЕсли;
		
		ПараметрыВызоваОбработчика = Новый Массив;
		ПараметрыВызоваОбработчика.Добавить(ПараметрыЗадания);
		ПараметрыВызоваОбработчика.Добавить(ИнформацияОбОшибкеВыполненияЗадания);
		
		Результат.ПараметрыВызоваОбработчика = ПараметрыВызоваОбработчика;
	Иначе
		Результат.ПараметрыВызоваОбработчика = Неопределено;
	КонецЕсли;

	Возврат Результат;
	
КонецФункции

// Формирует и возвращает таблицу имен регламентных заданий с признаком использования.
//
// Возвращаемое значение:
// ТаблицаЗначений - таблица, которую необходимо заполнить
// 	регламентными заданиями и признаком использования.
//
Функция ИспользованиеРегламентныхЗаданий()
	
	ТаблицаИспользования = Новый ТаблицаЗначений;
	ТаблицаИспользования.Колонки.Добавить("РегламентноеЗадание", Новый ОписаниеТипов("Строка"));
	ТаблицаИспользования.Колонки.Добавить("Использование", Новый ОписаниеТипов("Булево"));
	
	// Обязательно для этой подсистемы.
	НоваяСтрока = ТаблицаИспользования.Добавить();
	НоваяСтрока.РегламентноеЗадание = "ПланированиеОбработкиЗаданий";
	НоваяСтрока.Использование       = Истина;
	
	ОбработчикиСобытия = ОбщегоНазначения.ОбработчикиСлужебногоСобытия(
		"СтандартныеПодсистемы.РаботаВМоделиСервиса.ОчередьЗаданий\ПриОпределенииИспользованияРегламентныхЗаданий");
	
	Для каждого Обработчик Из ОбработчикиСобытия Цикл
		Обработчик.Модуль.ПриОпределенииИспользованияРегламентныхЗаданий(ТаблицаИспользования);
	КонецЦикла;
	
	ОчередьЗаданийПереопределяемый.ПриОпределенииИспользованияРегламентныхЗаданий(ТаблицаИспользования);
	
	Возврат ТаблицаИспользования;
	
КонецФункции

Функция КоличествоИсполняющихФоновыхЗаданий()
	
	Отбор = Новый Структура("Наименование, Состояние", ПолучитьНаименованиеИсполняющегоФоновогоЗадания(), СостояниеФоновогоЗадания.Активно); 
	ИсполняющиеФоновыеЗадания = ФоновыеЗадания.ПолучитьФоновыеЗадания(Отбор); 
	
	КоличествоРаботающихФоновыхЗаданий = ИсполняющиеФоновыеЗадания.Количество();
	
	Возврат КоличествоРаботающихФоновыхЗаданий;
	
КонецФункции

// Рассчитывает необходимое количество исполняющих фоновых заданий.
// 
Функция КоличествоИсполняющихФоновыхЗаданийКЗапуску()
	
	КоличествоРаботающихФоновыхЗаданий = КоличествоИсполняющихФоновыхЗаданий();
	
	КоличествоИсполняющихФоновыхЗаданийКЗапуску = 
		Константы.МаксимальноеКоличествоИсполняющихФоновыхЗаданий.Получить() - КоличествоРаботающихФоновыхЗаданий;
	
	Если КоличествоИсполняющихФоновыхЗаданийКЗапуску < 0 Тогда
		КоличествоИсполняющихФоновыхЗаданийКЗапуску = 0;
	КонецЕсли;

	Возврат КоличествоИсполняющихФоновыхЗаданийКЗапуску;
	
КонецФункции

// Запускает заданное количество фоновых заданий.
// 
// Параметры: 
// КоличествоЗапускаемыхФоновыхЗаданий - Число - количество фоновых заданий,
//                                       которых необходимо запустить.
//
Процедура ЗапуститьИсполняющееФоновоеЗадание(КоличествоЗапускаемыхФоновыхЗаданий) 
	
	Для Индекс = 1 По КоличествоЗапускаемыхФоновыхЗаданий Цикл
		Ключ = Новый УникальныйИдентификатор;
		Параметры = Новый Массив;
		Параметры.Добавить(Ключ);
		ФоновыеЗадания.Выполнить("ОчередьЗаданийСлужебный.ОбработатьОчередьЗаданий", Параметры, Ключ, ПолучитьНаименованиеИсполняющегоФоновогоЗадания());
	КонецЦикла;
	
КонецПроцедуры

Функция ПолучитьНаименованиеИсполняющегоФоновогоЗадания()
	
	Возврат "ИсполняющееФоновоеЗадание_5340185be5b240538bc73d9f18ef8df1";
	
КонецФункции

Процедура ЗаписьКонтроляВыполнения(Знач ИмяСобытия, Знач ЗаписьЗадания, Знач Комментарий = "")
	
	Если НЕ ПустаяСтрока(Комментарий) Тогда
		
		Комментарий = Комментарий + Символы.ПС;
		
	КонецЕсли;
	
	Если ТипЗнч(ЗаписьЗадания) = Тип("СправочникСсылка.ОчередьЗаданий") Тогда
		
		ИмяМетода = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ЗаписьЗадания, "ИмяМетода");
		
	Иначе
		
		ОписаниеМетода = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(ЗаписьЗадания, "ИмяМетода, Шаблон");
		
		Если ЗначениеЗаполнено(ОписаниеМетода.Шаблон) Тогда
			
			ИмяМетода = НСтр("ru = 'Шаблон:'") + ОписаниеМетода.Шаблон;
			
		Иначе
			
			ИмяМетода = ОписаниеМетода.ИмяМетода;
			
		КонецЕсли;
		
	КонецЕсли;
	
	ЗаписьЖурналаРегистрации(ИмяСобытия, УровеньЖурналаРегистрации.Информация, ,
		Строка(ЗаписьЗадания.УникальныйИдентификатор()), Комментарий + ИмяМетода + ";"
			+ ?(ОбщегоНазначенияПовтИсп.ЭтоРазделеннаяКонфигурация() И ОбщегоНазначения.ЭтоРазделенныйОбъектМетаданных(ЗаписьЗадания.Метаданные().ПолноеИмя(),
				ОбщегоНазначенияПовтИсп.РазделительВспомогательныхДанных()),
				Формат(ЗаписьЗадания.ОбластьДанныхВспомогательныеДанные, "ЧН=0; ЧГ="), "-1"));
	
КонецПроцедуры

// Выполняет обработчик задания созданного не на основе шаблона.
// 
// Параметры: 
// Псевдоним - Строка - псевдоним метода, который необходимо выполнить.
// Параметры - Массив - параметры передаются в ИмяМетода 
// в порядке расположения элементов массива.
// 
Процедура ВыполнитьОбработчикЗадания(Шаблон, Псевдоним, Параметры)
	
	ИмяМетода = ОчередьЗаданийСлужебныйПовтИсп.СоответствиеИменМетодовПсевдонимам().Получить(ВРег(Псевдоним));
	Если ИмяМетода = Неопределено Тогда
		ШаблонСообщения = НСтр("ru = 'Метод %1 не разрешен к вызову через очередь заданий.'");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, Псевдоним);
		ВызватьИсключение(ТекстСообщения);
	КонецЕсли;
	
	ВыполнитьМетодКонфигурации(ИмяМетода,Параметры);
	
КонецПроцедуры

Процедура ЗапланироватьЗадание(Знач Выборка)
	
	Если ЗначениеЗаполнено(Выборка.ЧасовойПояс) Тогда
		ЧасовойПояс = Выборка.ЧасовойПояс;
	Иначе
		ЧасовойПояс = Неопределено;
	КонецЕсли;
	
	Если Выборка.ОбластьДанных <> -1 Тогда
		
		Попытка
		
			ОбщегоНазначения.УстановитьРазделениеСеанса(Истина, Выборка.ОбластьДанных);
		
		Исключение
			
			ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
			
			ШаблонСообщения =
			    НСтр("ru = 'Задание очереди с именем метода %1 в области %2 не запланировано по причине:
				|%3'");
				
			Если ЗначениеЗаполнено(Выборка.Шаблон) Тогда
				
				ИмяМетода = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Выборка.Шаблон, "ИмяМетода");
				
			Иначе
				
				ИмяМетода = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Выборка.Идентификатор, "ИмяМетода");
				
			КонецЕсли;
			
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, ИмяМетода, Выборка.ОбластьДанных, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ЗаписьЖурналаРегистрации(
			    НСтр("ru = 'Очередь заданий.Планирование'",
			    ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()), 
			    УровеньЖурналаРегистрации.Ошибка,,,
				ТекстСообщения);
			
			Возврат;
			
		КонецПопытки;
		
	КонецЕсли;
	
	НачатьТранзакцию();
	
	Попытка
		
		Блокировка = Новый БлокировкаДанных;
		ЭлементБлокировки = Блокировка.Добавить(Выборка.Идентификатор.Метаданные().ПолноеИмя());
		ЭлементБлокировки.УстановитьЗначение("Ссылка", Выборка.Идентификатор);
		Блокировка.Заблокировать();
		
		Если НЕ ОбщегоНазначения.СсылкаСуществует(Выборка.Идентификатор) Тогда
			Блокировка.Заблокировать();
			РазблокироватьДанныеДляРедактирования(Выборка.Идентификатор);
			ОтменитьТранзакцию();
			Возврат;
		КонецЕсли;
		
		Задание = Выборка.Идентификатор.ПолучитьОбъект();
		
		Если ОбщегоНазначенияПовтИсп.ЭтоРазделеннаяКонфигурация() И ОбщегоНазначенияПовтИсп.ЭтоРазделенныйОбъектМетаданных(Задание.Метаданные().ПолноеИмя(), ОбщегоНазначенияПовтИсп.РазделительВспомогательныхДанных()) Тогда
			
			Если ЗначениеЗаполнено(Задание.Шаблон)
				И Выборка.Шаблон = Неопределено Тогда
				
				ШаблонСообщения = НСтр("ru = 'На найден шаблон задания очереди  %1'");
				ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, Задание.Шаблон);
				
				ЗаписьЖурналаРегистрации(НСтр("ru = 'Очередь заданий.Планирование'", 
					ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()), 
					УровеньЖурналаРегистрации.Ошибка,
					,
					,
					ТекстСообщения);
				
				ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
				РазблокироватьДанныеДляРедактирования(Выборка.Идентификатор);
				ОтменитьТранзакцию();
				Возврат;
				
			КонецЕсли;
			
		КонецЕсли;
			
		Если Задание.СостояниеЗадания = Перечисления.СостоянияЗаданий.ОшибкаВыполнения
			И Задание.НомерПопытки < Выборка.КоличествоПовторовПриАварийномЗавершении Тогда // Попытка повторного запуска
			
			Если ЗначениеЗаполнено(Задание.ДатаЗавершенияПоследнегоЗапуска) Тогда
				ТочкаОтсчетаПерезапуска = Задание.ДатаЗавершенияПоследнегоЗапуска;
			Иначе
				ТочкаОтсчетаПерезапуска = Задание.ДатаНачалаПоследнегоЗапуска;
			КонецЕсли;
			
			Задание.ЗапланированныйМоментЗапуска = ТочкаОтсчетаПерезапуска + Выборка.ИнтервалПовтораПриАварийномЗавершении;
			Задание.НомерПопытки                 = Задание.НомерПопытки + 1;
			Задание.СостояниеЗадания             = Перечисления.СостоянияЗаданий.Запланировано;
			Задание.ИсполняющееФоновоеЗадание    = Неопределено;
			ОбщегоНазначения.ЗаписатьВспомогательныеДанные(Задание);
			
		// Задание не было выполнено, запланируем обработчик ошибки.
		ИначеЕсли Задание.СостояниеЗадания = Перечисления.СостоянияЗаданий.Выполняется Тогда
			
			ЗаписьКонтроляВыполнения(НСтр("ru = 'Очередь регламентных заданий.Завершено с ошибками'", 
				ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()), Выборка.Идентификатор, 
				НСтр("ru = 'Исполняющее задание было принудительно завершено'"));
				
			// Запланируем разовое задание для выполнения обработчика ошибок.
			ПараметрыОбработчика = ПолучитьПараметрыОбработчикаОшибок(Задание);
			Если ПараметрыОбработчика.ОбработчикСуществует Тогда
				
				НовоеЗадание = Справочники[Задание.Метаданные().Имя].СоздатьЭлемент();
				НовоеЗадание.ЗапланированныйМоментЗапуска = ТекущаяУниверсальнаяДата();
				НовоеЗадание.Использование = Истина;
				НовоеЗадание.СостояниеЗадания = Перечисления.СостоянияЗаданий.Запланировано;
				ПараметрыВызова = Новый Массив;
				ПараметрыВызова.Добавить(Задание.Ссылка);
				НовоеЗадание.Параметры = Новый ХранилищеЗначения(ПараметрыВызова);
				НовоеЗадание.ИмяМетода = "ОчередьЗаданийСлужебный.ОбработатьОшибку";
				Если ОбщегоНазначения.ЭтоРазделенныйОбъектМетаданных(Задание.Метаданные(),"ОбластьДанныхВспомогательныеДанные") Тогда
					НовоеЗадание.ОбластьДанныхВспомогательныеДанные = Задание.ОбластьДанныхВспомогательныеДанные;
				КонецЕсли;
				ОбщегоНазначения.ЗаписатьВспомогательныеДанные(НовоеЗадание);
				
				// Останавливаем выполнение задания пока не будет выполнен обработчик ошибок.
				Задание.СостояниеЗадания = Перечисления.СостоянияЗаданий.ОбработкаОшибкиПриАварийномЗавершении;
				
			Иначе
				
				Задание.СостояниеЗадания = Перечисления.СостоянияЗаданий.ОшибкаВыполнения;
				
			КонецЕсли;
			
				ОбщегоНазначения.ЗаписатьВспомогательныеДанные(Задание);
			
		Иначе
			Расписание = Выборка.Расписание.Получить();
			Если Расписание <> Неопределено Тогда
				
				Задание.ЗапланированныйМоментЗапуска = ПолучитьЗапланированныйМоментЗапускаЗадания(
					Расписание, ЧасовойПояс, Задание.ДатаНачалаПоследнегоЗапуска, Задание.ДатаЗавершенияПоследнегоЗапуска);
				Задание.НомерПопытки = 0;
				Если ЗначениеЗаполнено(Задание.ЗапланированныйМоментЗапуска) Тогда
					Задание.СостояниеЗадания = Перечисления.СостоянияЗаданий.Запланировано;
				Иначе
					Задание.СостояниеЗадания = Перечисления.СостоянияЗаданий.НеАктивно;
				КонецЕсли;
				Задание.ИсполняющееФоновоеЗадание = Неопределено;
				ОбщегоНазначения.ЗаписатьВспомогательныеДанные(Задание);
				
			Иначе // Нет расписания
				
				Если ОбщегоНазначенияПовтИсп.ЭтоРазделеннаяКонфигурация() И ОбщегоНазначенияПовтИсп.ЭтоРазделенныйОбъектМетаданных(
							Задание.Метаданные().ПолноеИмя(),
							ОбщегоНазначенияПовтИсп.РазделительВспомогательныхДанных()) Тогда
					Если ЗначениеЗаполнено(Задание.Шаблон) Тогда // Задание по шаблону без расписания.
						
						ШаблонСообщения = НСтр("ru = 'Для шаблон заданий очереди  %1 не найдено расписание'");
						ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, Задание.Шаблон);
						ЗаписьЖурналаРегистрации(НСтр("ru = 'Очередь заданий.Планирование'", 
							ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()), 
							УровеньЖурналаРегистрации.Ошибка,
							,
							,
							ТекстСообщения);
						
						ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
						ОтменитьТранзакцию();
						РазблокироватьДанныеДляРедактирования(Выборка.Идентификатор);
						Возврат;
						
					КонецЕсли;
				КонецЕсли;
				
				// Разовое задание
				Задание.ОбменДанными.Загрузка = Истина;
				Задание.Удалить();
				
			КонецЕсли;
		КонецЕсли;
		
		ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
		ЗафиксироватьТранзакцию();
		РазблокироватьДанныеДляРедактирования(Выборка.Идентификатор);
		
	Исключение
		
		ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
		ОтменитьТранзакцию();
		РазблокироватьДанныеДляРедактирования(Выборка.Идентификатор);
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

Процедура ВыполнитьЗаданиеОчереди(Знач Ссылка, Знач ИсполняющееФоновоеЗадание, 
		Знач Шаблон, Знач ИмяМетода)
	
	ОбластьДанных = Неопределено;
	Если ОбщегоНазначенияПовтИсп.ЭтоРазделеннаяКонфигурация() Тогда
		МодульОчередьЗаданийСлужебныйРазделениеДанных = ОбщегоНазначения.ОбщийМодуль("ОчередьЗаданийСлужебныйРазделениеДанных");
		ПереопределеннаяОбластьДанных = МодульОчередьЗаданийСлужебныйРазделениеДанных.ОпределитьОбластьДанныхДляЗадания(Ссылка);
		Если ПереопределеннаяОбластьДанных <> Неопределено Тогда
			ОбластьДанных = ПереопределеннаяОбластьДанных;
		КонецЕсли;
	КонецЕсли;
	
	Если ОбластьДанных = Неопределено Тогда
		ОбластьДанных = -1;
	КонецЕсли;
	
	НачатьТранзакцию();
	Попытка
		
		Если ОбластьДанных <> -1 Тогда
			ОбщегоНазначения.УстановитьРазделениеСеанса(Истина, ОбластьДанных);
		КонецЕсли;
		
		Блокировка = Новый БлокировкаДанных;
		ЭлементБлокировки = Блокировка.Добавить(Ссылка.Метаданные().ПолноеИмя());
		ЭлементБлокировки.УстановитьЗначение("Ссылка", Ссылка);
		Блокировка.Заблокировать();
		
		Задание = Ссылка.ПолучитьОбъект();
		
		Если Задание.СостояниеЗадания = Перечисления.СостоянияЗаданий.Запланировано
			И Задание.Использование
			И Задание.ЗапланированныйМоментЗапуска <= ТекущаяУниверсальнаяДата() Тогда 
			
			Задание.СостояниеЗадания = Перечисления.СостоянияЗаданий.Выполняется;
			Задание.ИсполняющееФоновоеЗадание = ИсполняющееФоновоеЗадание.УникальныйИдентификатор;
			Задание.ДатаНачалаПоследнегоЗапуска = ТекущаяУниверсальнаяДата();
			Задание.ДатаЗавершенияПоследнегоЗапуска = Неопределено;
			ОбщегоНазначения.ЗаписатьВспомогательныеДанные(Задание);
			
			ЗафиксироватьТранзакцию();
			
		Иначе
			
			ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
			ЗафиксироватьТранзакцию();
			Возврат;
			
		КонецЕсли;
		
	Исключение
		
		ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;
	
	// Выполнение задания
	ВыполненоУспешно = Ложь;
	ИнформацияОбОшибкеВыполненияЗадания = Неопределено;
	Попытка
		ЗаписьКонтроляВыполнения(НСтр("ru = 'Очередь регламентных заданий.Старт'", 
			ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()), Ссылка);
		
		Если ЗначениеЗаполнено(Шаблон) Тогда
			ВыполнитьМетодКонфигурации(ИмяМетода);
		Иначе
			ВыполнитьОбработчикЗадания(Шаблон, ИмяМетода, Задание.Параметры.Получить());
		КонецЕсли;
		
		ВыполненоУспешно = Истина;
		
		ЗаписьКонтроляВыполнения(НСтр("ru = 'Очередь регламентных заданий.Завершено успешно'", 
			ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()), Ссылка);
		
	Исключение
		
		ИнформацияОбОшибкеВыполненияЗадания = ИнформацияОбОшибке();
		
		ЗаписьКонтроляВыполнения(НСтр("ru = 'Очередь регламентных заданий.Завершено с ошибками'", 
			ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()), Ссылка, 
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибкеВыполненияЗадания));
		
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Очередь регламентных заданий.Выполнение'", 
			ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка, 
			,
			ИсполняющееФоновоеЗадание, 
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибкеВыполненияЗадания)); 
			
		
	КонецПопытки;
		
	Если НЕ ВыполненоУспешно Тогда
		
		// Вызов обработчиков ошибок
		ОбработатьОшибку(Ссылка, ИнформацияОбОшибкеВыполненияЗадания);
		
	КонецЕсли;
	
	НачатьТранзакцию();
	Попытка
		
		Если ОбщегоНазначения.СсылкаСуществует(Ссылка) Тогда // Иначе - задание могло быть удалено внутри обработчика.
			
			Блокировка = Новый БлокировкаДанных;
			ЭлементБлокировки = Блокировка.Добавить(Ссылка.Метаданные().ПолноеИмя());
			ЭлементБлокировки.УстановитьЗначение("Ссылка", Ссылка);
			Блокировка.Заблокировать();
			
			Задание = Ссылка.ПолучитьОбъект();
			Задание.ДатаЗавершенияПоследнегоЗапуска = ТекущаяУниверсальнаяДата();
			
			Если ВыполненоУспешно Тогда
				Задание.СостояниеЗадания = Перечисления.СостоянияЗаданий.Завершено;
			Иначе
				Задание.СостояниеЗадания = Перечисления.СостоянияЗаданий.ОшибкаВыполнения;
			КонецЕсли;
			ОбщегоНазначения.ЗаписатьВспомогательныеДанные(Задание);
			
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		
		ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;
	
	ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обновление информационной базы.

// Добавляет процедуры-обработчики обновления, необходимые данной подсистеме.
//
// Параметры:
//  Обработчики - ТаблицаЗначений - см. описание функции НоваяТаблицаОбработчиковОбновления
//                                  общего модуля ОбновлениеИнформационнойБазы.
// 
Процедура ПриДобавленииОбработчиковОбновления(Обработчики) Экспорт
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "*";
	Обработчик.Процедура = "ОчередьЗаданийСлужебный.УстановитьИспользованиеРегламентныхЗаданий";
	Обработчик.ОбщиеДанные = Истина;
	Обработчик.Приоритет = 50;
	Обработчик.МонопольныйРежим = Ложь;
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.1.3.9";
	Обработчик.Процедура = "ОчередьЗаданийСлужебный.ПеренестиЗаданияВОчередиВНеразделенныеДанные";
	Обработчик.ОбщиеДанные = Истина;
	Обработчик.ВыполнятьВГруппеОбязательных = Истина;
	Обработчик.Приоритет = 80;
	Обработчик.МонопольныйРежим = Истина;
	
КонецПроцедуры

// Отключает регламентные задания задания используемые только в локальном режиме
// и включает используемые только в модели сервиса.
//
Процедура УстановитьИспользованиеРегламентныхЗаданий() Экспорт
	
	ТаблицаИспользованияРегламентныхЗаданийВМоделиСервиса = ИспользованиеРегламентныхЗаданий();
	
	Для Каждого Строка Из ТаблицаИспользованияРегламентныхЗаданийВМоделиСервиса Цикл
		
		Если ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
			
			// Включаем регламентные задания, предназначенные для использования в модели сервиса.
			// Отключаем регламентные задания, предназначенные для использования в локальном режиме.
			ТребуемоеИспользование = Строка.Использование;
			
		Иначе
			
			Если Строка.Использование Тогда
				// Отключаем регламентные задания, предназначенные для использования в модели сервиса.
				ТребуемоеИспользование = Ложь;
			Иначе
				// Не изменяем настройки заданий, предназначенных для использования в локальном режиме.
				Продолжить;
			КонецЕсли;
			
		КонецЕсли;
		
		Отбор = Новый Структура("Метаданные", Метаданные.РегламентныеЗадания[Строка.РегламентноеЗадание]);
		НайденныеРегламентныеЗадания = РегламентныеЗадания.ПолучитьРегламентныеЗадания(Отбор);
		
		Для Каждого РегламентноеЗадание Из НайденныеРегламентныеЗадания Цикл
			
			Если РегламентноеЗадание.Использование <> ТребуемоеИспользование Тогда
				РегламентноеЗадание.Использование = ТребуемоеИспользование;
				РегламентноеЗадание.Записать();
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

// Переносит задания из РС ОчередьЗаданий в справочник ОчередьЗаданий.
Процедура ПеренестиЗаданияВОчередиВНеразделенныеДанные() Экспорт
	
	НачатьТранзакцию();
	
	Попытка
		
		Блокировка = Новый БлокировкаДанных();
		БлокировкаСправочника = Блокировка.Добавить("Справочник.ОчередьЗаданий");
		БлокировкаСправочника.Режим = РежимБлокировкиДанных.Исключительный;
		Блокировка.Заблокировать();
		
		ТекстЗапроса = 
		"ВЫБРАТЬ
		|	УдалитьОчередьЗаданий.Использование,
		|	УдалитьОчередьЗаданий.ЗапланированныйМоментЗапуска,
		|	УдалитьОчередьЗаданий.СостояниеЗадания,
		|	УдалитьОчередьЗаданий.ИсполняющееФоновоеЗадание,
		|	УдалитьОчередьЗаданий.ЭксклюзивноеВыполнение,
		|	УдалитьОчередьЗаданий.Шаблон,
		|	УдалитьОчередьЗаданий.НомерПопытки,
		|	УдалитьОчередьЗаданий.УдалитьРегламентноеЗадание,
		|	УдалитьОчередьЗаданий.ИмяМетода,
		|	УдалитьОчередьЗаданий.Параметры,
		|	УдалитьОчередьЗаданий.ДатаНачалаПоследнегоЗапуска,
		|	УдалитьОчередьЗаданий.Ключ,
		|	УдалитьОчередьЗаданий.ИнтервалПовтораПриАварийномЗавершении,
		|	УдалитьОчередьЗаданий.Расписание,
		|	УдалитьОчередьЗаданий.КоличествоПовторовПриАварийномЗавершении,
		|	УдалитьОчередьЗаданий.Идентификатор
		|ИЗ
		|	РегистрСведений.УдалитьОчередьЗаданий КАК УдалитьОчередьЗаданий
		|ГДЕ
		|	УдалитьОчередьЗаданий.ОбластьДанных = -1";
		Запрос = Новый Запрос(ТекстЗапроса);
		Выборка = Запрос.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			
			СсылкаЗадания = Справочники.ОчередьЗаданий.ПолучитьСсылку(
				Новый УникальныйИдентификатор(Выборка.Идентификатор));
			
			Если ОбщегоНазначения.СсылкаСуществует(СсылкаЗадания) Тогда
				НовоеЗадание = СсылкаЗадания.ПолучитьОбъект();
			Иначе
				НовоеЗадание = Справочники.ОчередьЗаданий.СоздатьЭлемент();
			КонецЕсли;
			
			ЗаполнитьЗначенияСвойств(НовоеЗадание, Выборка);
			ОбщегоНазначения.ЗаписатьВспомогательныеДанные(НовоеЗадание);
			
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

#КонецОбласти
